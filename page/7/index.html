<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 7 | CyannyLive | AI and Big Data</title>

  
  <meta name="author" content="Cyanny Liang">
  

  
  <meta name="description" content="Wisdom comes from inside">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="CyannyLive"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="CyannyLive" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">CyannyLive</a>
    </h1>
    <p class="site-description">AI and Big Data</p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about/">About</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2013/09/09/warshall-algorithm-cycle-dectection/"><span>Warshall&#39;s Algorithm for Cycle Dectection</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/09/09/warshall-algorithm-cycle-dectection/" rel="bookmark">
        <time class="entry-date published" datetime="2013-09-09T13:03:54.000Z">
          2013-09-09
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>今天上系统分析与设计课，老师提到了Warshall算法做函数调用关系的Cycle Detection, 想起当年的离散，这一章还真没有什么印象了。翻开陈年旧书看看，就跟看见陌生人一样，基础还是需要在加强一下啦。今天上课提到的几个点，比如死锁，Dijkstra Algorithm，DFS，Unix多级反馈调度，Android卡顿缘由等，自己没能第一时间想出来，就留作以后闲暇时光google的题目吧。现在花了一个小时，用Java把Warshall算法实现了，总觉得用一个小时是不是有点长了。</p>
<h3 id="Warshall算法要义："><a href="#Warshall算法要义：" class="headerlink" title="Warshall算法要义："></a>Warshall算法要义：</h3><ol>
<li><p> 邻接矩阵: 表示图关系的矩阵，看看离散数学就懂了</p>
</li>
<li><p> 传递闭包：从邻接矩阵的每一个顶点出发，求出的所有顶点的到达情况，该矩阵就是传递闭包。说是闭包是因为它满足自反性、对称性和传递性。</p>
</li>
<li><p>Warshall算法就是从邻接矩阵中求出传递闭包。[more…]</p>
<p> 例如:</p>
<p> 邻接矩阵为：</p>
<p> [0, 1, 0, 0,</p>
<p> 1, 0, 1, 0,</p>
<p> 0, 0, 0, 1,</p>
<p> 0, 0, 0, 0]</p>
<p> 传递闭包为：</p>
<p> [1, 1, 1, 1</p>
<p> 1, 1, 1, 1,</p>
<p> 0, 0, 0, 1,</p>
<p> 0, 0, 0, 0]</p>
<p> 算法很简单，直接上一个代码描述：<br>[java]<br>public void warshallDetect(int[] matrix) {<br>closure = matrix;<br>for (int k = 0; k &lt; n; k++) {<br>for (int i = 0; i &lt; n; i++) {<br> for (int j = 0; j &lt; n; j++) {<br>   if (closure[i, k] == 1 &amp;&amp; closure[k, j] == 1) {</p>
<pre><code> closure[i, j] = 1</code></pre>
<p>   }<br> }<br>}<br>}<br>}<br>[/java]<br>程序的意思是：<br>M(0): 初始矩阵，从每一点到另一个点不能有中间节点，即最初的矩阵。</p>
<p> M(1): 在M(0)基础上，从每一个顶点出发，让第1个顶点作为中间节点，检测是否有关系。</p>
<p> M(2): 在M(1)基础上，从每一个顶点出发，让第2个顶点作为中间节点，检测是否有关系。</p>
<p> M(k): 在M(k-1)基础上，从每一个顶点出发，让第k个顶点作为中间节点，检测是否有关系。</p>
<p> M(n): 在M(n - 1)基础上，从每一个顶点出发，让第n个顶点作为中间节点，检测是否有关系。</p>
<p> 最终生成一个传递闭包，检测哪些顶点有循环调用就显而易见了。</p>
<p> <a target="_blank" rel="noopener" href="https://github.com/lgrcyanny/Algorithm/blob/master/src/com/algorithm/warshall/CycleDetection.java" title="Warshall Cycle Detection Source Code">源代码在此。</a></p>
<p> <a target="_blank" rel="noopener" href="http://www.cnblogs.com/lpshou/archive/2012/04/27/2473109.html" title="参考博客">参考博客</a></p>
</li>
</ol>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/algorithm/">Algorithm</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/learning/">Learning</a><a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/09/09/warshall-algorithm-cycle-dectection/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/08/18/the-usage-of-counting-sort/"><span>计数排序的应用</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/08/18/the-usage-of-counting-sort/" rel="bookmark">
        <time class="entry-date published" datetime="2013-08-18T12:00:44.000Z">
          2013-08-18
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>比较排序是我们常见的排序方法，如Insertion Sort, Merge Sort, Quick Sort, Heap Sort都有O(n*lgn)的下界，而如何让一个排序能在最短的线性时间O(n)内排序呢？就要求助于Counting Sort计数排序，该算法的基本思想是对数组中出现的数字进行计数，通过计数计算出每一个数字的排位，并按排位给出结果。计数排序明显的在时间上优于快排，以空间换时间，这个排序思想很像在编程珠玑的开篇中提到的按位排序，计数排序还有个好处是稳定的。</p>
<p>计数排序的应用主要是基数排序(Radix Sort),但是我试过排序一百万个数字，基数排序的时间虽然是O(n),但可能是常系数的因子太大，执行时间并不比快排理想，只能算是为了学习嘛，试验一下了。</p>
<p>虽然计数排序看着很快，万物都有利有弊，计数排序有一个前提，需要知道输入数据的分布，即最大值和最小值，如果不知道的话，还是快排最好。而基数排序则更适用于输入的数据位数都相同。</p>
<p>对于计数排序，其代码如下：[more…]<br>[java]<br>public void sort() {<br>  count = new int[k + 1];<br>  results = new int[data.length];<br>  int i;<br>  for (i = 0; i &lt; count.length; i++) {<br>    count[i] = 0;<br>  }<br>  // 对数组进行计数<br>  for (i = 0; i &lt; data.length; i++) {<br>    count[data[i]]++;<br>  }<br>  // 计算每一个数字的排名<br>  for (i = 1; i &lt; count.length; i++) {<br>    count[i] += count[i - 1];<br>  }<br>  // 按排名输出到结果数组中<br>  for (i = data.length - 1; i &gt;= 0; i–) {<br>    results[count[data[i]] - 1] = data[i];<br>    count[data[i]]–;<br>  }<br>}<br>[/java]</p>
<h2 id="计数排序的应用一"><a href="#计数排序的应用一" class="headerlink" title="计数排序的应用一"></a>计数排序的应用一</h2><p><strong>算法导论思考题8-3-a</strong></p>
<p><em>给定一个整数数组，其中不同的整数中包含的数字个数可能不同，但该数组中，所有整数中的总的数字数为n。说明如何在O(n)的时间内对该数组排序。</em></p>
<p>分析： 该数组的每个数字的位数不相同，直接用radix sort不好，需要做一些改进。其方法是用counting sort，按整数的位数给整数排序，再对相同位数的一段整数用基数排序，算法时间O(n)。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lgrcyanny/Algorithm/blob/master/src/com/algorithm/lineartimesort/VaringLengthNumberSort.java">Source Code</a></p>
<h2 id="计数排序的应用二"><a href="#计数排序的应用二" class="headerlink" title="计数排序的应用二"></a>计数排序的应用二</h2><p><strong>算法导论思考题8-3-b</strong></p>
<p><em>给定一个字符串数组，其中不同的串包含的字符数可能不同，但所有的串中总的字符个数为n。说明如何在O(n)的时间内对该数组进行排序</em></p>
<p>分析：该问题的难度出现在字符串上，字符串的排序不像数字，位数多的比位数少的大，字符串的排序需要按字典顺序来。这个算法的基本思想是先对所有的字符串按首字母进行Counting Sort, 然后再递归地对相同首字母的字符串的第二个字符进行Counting Sort，以此类推，递归排序第三，第四…个字符。</p>
<p>算法的边界问题容易出错，debug花了我两个小时，不过能编出来实属不易。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/lgrcyanny/Algorithm/blob/master/src/com/algorithm/lineartimesort/VaringLengthStringSort.java">Source Code</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/algorithm/">Algorithm</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a><a href="/tags/sort/">sort</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/08/18/the-usage-of-counting-sort/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/08/10/learning-heap-sort/"><span>再叙堆排序</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/08/10/learning-heap-sort/" rel="bookmark">
        <time class="entry-date published" datetime="2013-08-10T13:45:36.000Z">
          2013-08-10
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>这个暑假，开始看《算法导论》，这是一本很厚的书，不过本着坚持就是胜利的原则，我选择一点点坚持，最近看到了堆排序。这是自己曾经靠背和记才慢慢理解的算法，而今重温，发现这个排序其实很简单，只需完成三点:</p>
<p>1. 实现MaxHeapify函数, 也就是以递归或者循环的方式，让每一节点保持最大堆的性质。这是堆排序的核心函数，写好了，就万事大吉了。</p>
<p>2. Build-Max-Heap, 利用MaxHeapify函数构建一个最大堆。</p>
<p>3. HeapSort,实现堆排： 先构建最大堆，再循环将第一个元素和最后一个元素交换，即把最大的元素换到最后，heapSize减1，最后对第一个元素调用MaxHeapify函数，保持最大堆的性质。</p>
<p>看起来，堆排很好，最佳和最坏的复杂度都是O(n*lgn)，但实际应用中quicksort是一个比堆排更好的算法,速度比堆排更快。但堆的数据结构对实现优先级队列有很大意义。<br><a target="_blank" rel="noopener" href="https://github.com/lgrcyanny/Algorithm/blob/master/src/com/algorithm/heap/HeapSort.java" title="Source Code">Source Code</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/algorithm/">Algorithm</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/learning/">Learning</a><a href="/tags/algorithm/">algorithm</a><a href="/tags/sort/">sort</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/08/10/learning-heap-sort/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/05/25/good-resources-for-js-learning/"><span>Good Resources for JavaScript</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/05/25/good-resources-for-js-learning/" rel="bookmark">
        <time class="entry-date published" datetime="2013-05-25T06:22:30.000Z">
          2013-05-25
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Easy to use</p>
<p><a target="_blank" rel="noopener" href="http://twitter.github.com/bootst" title="Bootstrap">http://twitter.github.com/bootst</a> - Twitter Bootstrap </p>
<p><a target="_blank" rel="noopener" href="http://foundation.zurb.com/" title="Zurb Foundation">http://foundation.zurb.com/</a> - Zurb Foundation</p>
<p>Typography</p>
<p><a target="_blank" rel="noopener" href="http://www.google.com/webfonts" title="Google Web Fonts">http://www.google.com/webfonts</a> - Google Web Fonts</p>
<p><a target="_blank" rel="noopener" href="https://typekit.com/" title="Typekit">https://typekit.com/ </a>- Typekit</p>
<p><a target="_blank" rel="noopener" href="http://letteringjs.com/" title="Lettering JS">http://letteringjs.com/</a> - LetteringJS</p>
<p><a target="_blank" rel="noopener" href="http://letteringjs.com/" title="KernJS">http://www.kernjs.com/</a> - KernJS</p>
<p><a target="_blank" rel="noopener" href="http://dailyjs.com/" title="DailyJS">http://www.dailyjs.com/</a> - DailyJS</p>
<p><a target="_blank" rel="noopener" href="http://compass-style.org/" title="Compass framework">http://compass-style.org/ </a> - Compass framework</p>
<p><a target="_blank" rel="noopener" href="http://lesscss.org/" title="Less">http://lesscss.org/</a> - CSS Preprocessor Less</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/javascript/">JavaScript</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/learning/">Learning</a><a href="/tags/javascript/">JavaScript</a><a href="/tags/resource/">Resource</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/05/25/good-resources-for-js-learning/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/6/" class="pagination-prev">Prev</a>
  
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Copyright
    </br>
    
    &copy; 2021 Cyanny Liang
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-40624708-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>