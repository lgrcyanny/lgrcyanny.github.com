<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>CyannyLive</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Think More Action More">
<meta property="og:type" content="website">
<meta property="og:title" content="CyannyLive">
<meta property="og:url" content="http://www.cyanny.com/page/5/index.html">
<meta property="og:site_name" content="CyannyLive">
<meta property="og:description" content="Think More Action More">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CyannyLive">
<meta name="twitter:description" content="Think More Action More">
<meta name="twitter:creator" content="@lgrcyanny">
<link rel="publisher" href="lgrcyanny">
<meta property="fb:admins" content="lgrcyanny">
<meta property="fb:app_id" content="lgrcyanny">
  
  
    <link rel="icon" href="favicon.ico">
  
  <link href='//fonts.useso.com/css?family=Open+Sans:400italic,400,600' rel='stylesheet' type='text/css'>
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css" type="text/css">
  

  
</head>
<body>
  <div id="container">
    <header id="header">
  <div id="header-main" class="header-inner">
    <div class="outer">
      <a href="/." id="logo"><i class="logo"></i><span class="site-title">CyannyLive</span></a>
      <nav id="main-nav">
        
          <a class="main-nav-link" href="/.">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/categories">Categories</a>
        
          <a class="main-nav-link" href="/tags">Tags</a>
        
          <a class="main-nav-link" href="/jianyinjietu">剪影截图</a>
        
      </nav>
      
      <nav id="sub-nav">
        <div class="profile" id="profile-nav">
          <a id="profile-anchor" href="javascript:;"><img class="avatar" src="/css/images/avatar.png"><i class="fa fa-caret-down"></i></a>
        </div>
      </nav>
      
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="http://www.cyanny.com"></form>
      </div>
    </div>
  </div>
  <div id="main-nav-mobile" class="header-sub header-inner">
    <table class="menu outer">
      <tr>
      
        <td><a class="main-nav-link" href="/.">Home</a></td>
      
        <td><a class="main-nav-link" href="/archives">Archives</a></td>
      
        <td><a class="main-nav-link" href="/categories">Categories</a></td>
      
        <td><a class="main-nav-link" href="/tags">Tags</a></td>
      
        <td><a class="main-nav-link" href="/jianyinjietu">剪影截图</a></td>
      
      <td>
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://www.cyanny.com"></form>
      </td>
      </tr>
    </table>
  </div>
</header>

    <div class="outer">
      
        <aside id="profile">
  <div class="inner profile-inner">
  	<div class="base-info profile-block">
		  <img id="avatar" src="/css/images/avatar.png">
      <h2 id="name">Cyanny Liang</h2>
      <h3 id="title">Big Data &amp; Cloud Computing</h3>
      <span id="location"><i class="fa fa-map-marker"></i>Beijing, China</span>
      <a id="follow" href="https://github.com/lgrcyanny/">FOLLOW</a>
  	</div>
    <div class="article-info profile-block">
      <div class="article-info-block">
        43
        <span>posts</span>
      </div>
      <div class="article-info-block">
        24
        <span>tags</span>
      </div>
    </div>
    
    <div class="contact-info profile-block">
      <table class="contact-list">
        <tr>
        
          <td><a href="http://github.com/lgrcyanny" target="_blank" title="github"><i class="fa fa-github"></i></a></td>
        
          <td><a href="https://twitter.com/lgrcyanny" target="_blank" title="twitter"><i class="fa fa-twitter"></i></a></td>
        
          <td><a href="https://www.facebook.com/CyannyLIANG" target="_blank" title="facebook"><i class="fa fa-facebook"></i></a></td>
        
          <td><a href="/atom.xml" target="_blank" title="rss"><i class="fa fa-rss"></i></a></td>
        
        </tr>
      </table>
    </div>
    
  </div>
</aside>
      
      <section id="main">
      <article id="post-system-analysis-design-kenneth-kendall-review-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/27/system-analysis-design-kenneth-kendall-review-part2/">System Analysis and Design (Kenneth Kendall) Review Part2</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2013/11/27/system-analysis-design-kenneth-kendall-review-part2/">
    <time datetime="2013-11-27T03:07:46.000Z" itemprop="datePublished">2013-11-27</time>
  </a>
</div>
          
  <div class="article-category">
  	<i class="fa fa-folder"></i>
    <a class="article-category-link" href="/categories/System-Analysis-and-Design/">System Analysis and Design</a>
  </div>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="4-_分析：使用数据流图">4. 分析：使用数据流图</h2><h3 id="4-1-数据流图功能和优点">4.1.数据流图功能和优点</h3><p>概念化数据在整个组织是如何流动的，数据经历的过程和变换，以及输出。<br>优点：<br>(1) 不必过早着手系统和技术的实现。<br>(2) 进一步了解系统和子系统的相互关系。<br>(3) 通过数据流图与用户交流当前系统的知识。<br>(4) 更好地了解业务，分析建议的系统以确定是否定义了必要的数据和过程。[more…]</p>
<h3 id="4-2-数据流图的图例规范">4.2.数据流图的图例规范</h3><p><img src="http://i42.tinypic.com/105a914.jpg" alt=""><br>1. 实体的命名：名词<br>2. 数据流命名：名词<br>3. 过程命名<br>在上下文图中，赋予整个系统的名称， 如“选课系统”<br>命名子系统时，使用诸如“预定子系统”， “Web用户执行系统”<br>具体过程命名：动词+形容词+名词 “计算净工资”，每一个过程要有一个唯一编号，指出它在图中的层次。</p>
<h3 id="4-3-开发数据流图步骤">4.3.开发数据流图步骤</h3><p>1. 步骤<br>1)制定一个业务活动列表：实体，数据流，过程，数据存储<br>2)创建上下文图，外部实体+输入+输出+系统，没有过程和数据存储<br>3)0层图：分解系统，展示高层的过程和数据存储，过程一般不超过9个，为避免数据流线交叉，同一个实体和数据存储可以出现多次。<br>4)画0层图中每个过程的子图<br>注意编号与父过程相同<br>纵向平衡——不能有父过程没有的输入和输出。<br>子图中通常不显示实体，显示接口数据流。<br>可以有父过程中没有显示的数据存储。<br>5)检查错误：编号正确，命名正确，输入输出清晰，没有back hole, 没有miracle<br>6)根据逻辑数据流图，开发物理数据流图：通过名字描述真实地文件和报表的物理存储，增加控制以指出合适过程完成或发生错误。<br>7)分割物理数据流图。</p>
<p>2. 注意点<br>1) 图例和标识的准确性<br>2) 数据流：不能从实体到实体，不能存储到存储，可以从实体到过程，过程到过程，过程到存储<br>3) 数据流图的层次性<br>4) 尽量不要有线性流，即一个输入和输出的过程，出现通常是遗漏了数据流，一个过程输入和输出总数在&gt;=4个以上最好。<br>5) 用户要能理解</p>
<h3 id="4-4_如何向用户解释数据流图">4.4 如何向用户解释数据流图</h3><p>1. 数据流图的标记要具体而有意义、<br>2.可以通过举例，类比和问询，让用户了解DFD的原理<br>3.每个DFD的过程控制在9个以内，太大的图，则要分解，保证在一页纸内<br>4.结合表格和图表向用户解释</p>
<h3 id="4-5-逻辑数据流图_vs_物理数据流图">4.5.逻辑数据流图 vs 物理数据流图</h3><p>1) 二者的区别<br><img src="http://i44.tinypic.com/11r86lx.jpg" alt=""></p>
<p>2)逻辑数据流图优势<br>a)更好地与用户交流<br>b)系统更稳定<br>c)更好地了解业务<br>d)灵活、更易维护<br>e)消除冗余，更容易创建物理模型</p>
<p>3)物理数据流图优势<br>a)澄清哪些过程是手工的，哪些是自动的<br>b)更详细的描述过程<br>c)标识临时数据存储<br>d)指定真实地文件名和打印输出名<br>e)增加确保正确地完成过程的控制。<br>物理数据流图创建方法：事件建模法，用例法.</p>
<p><img src="http://i44.tinypic.com/xnyzbo.jpg" alt=""></p>
<h2 id="5-_使用数据字典分析系统">5. 使用数据字典分析系统</h2><h3 id="5-1-数据字典的基本概念">5.1.数据字典的基本概念</h3><p>1.数据字典定义<br>是一种关于数据的数据参考书，指导系统的分析与设计，包括数据流，数据结构，数据元素和数据存储。</p>
<p>2.数据字典的必要性<br>a)作为数据的记录文档<br>b)消除冗余，保证数据的一致性<br>c)验证DFD的完备性和准确性<br>d)为开发界面和报表提供切入点<br>e)找出数据流图中过程的逻辑<br>f)创建XML</p>
<p>3.DFD与数据字典的关系<br><img src="http://i42.tinypic.com/28k6bud.jpg" alt=""></p>
<h3 id="5-2_数据流的描述">5.2 数据流的描述</h3><p>通过DFD确定系统的输入和输出，对每个数据流描述如下，具体实例可以看书。<br>1)ID：可选标识符<br>2)数据流名称<br>3)数据流描述<br>4)数据流来源<br>5)数据流目标<br>6)数据流类型：文件、界面、报表、表格或内部数据(中间的临时数据)<br>7)包含的数据结构<br>8)单位时间的流量<br>9)备注</p>
<h3 id="5-3-数据结构描述">5.3.数据结构描述</h3><p>1.描述<br>1)= 表示组成<br>2)+ 表示“和”<br>3){} 表示重复元素，一定有至少一个 1~n，可以包含固定重复次数，或上限与下限<br>4)[] “非此即彼”，互斥的选择<br>5)() 表示可选元素 0~1<br><img src="http://i42.tinypic.com/256fnuc.jpg" alt=""></p>
<p>2.逻辑数据结构和物理数据结构<br>逻辑数据结构是业务上，用户看到的数据。物理数据结构是软件实现所需要的数据。<br>物理数据结构需要增加：<br>1)键字段，唯一标识一条记录<br>2)标识主记录的状态代码，诸如一个雇员当前被雇佣或否。<br>3)如果一个文件包含不同的记录类型，则可以用交易码标识记录的类型。例如，包含返还项的记录和支付记录的信用文件。<br>4)重复组数据项，包含该组中有多少个数据项的计数。<br>5)重复组中数据项多少的限制<br>6)客户访问一个安全Web站点的密码。</p>
<h3 id="5-4_数据元素描述">5.4 数据元素描述</h3><p>1)ID, 可选的<br>2)元素名称<br>3)别名<br>4)简短描述<br>5)是基本元素还是派生元素</p>
<p>6)元素长度：<br>对于数值金额的长度，给出最大数额。<br>名称和地址，给出合适的长度<br>对于其他字段，参照历史数据</p>
<p>7)数据类型：数值，日志，字母，varchar，字符<br>8)如果用特殊编码符号表明应当如何表示数据，则应包含输入和输出的格式。</p>
<p>9)验证标准，保证数据的精确性，对于离散或连续的数据有以下标准<br>a)某个值范围适合包含连续数据，如GPA 0.00~4.00<br>b)如果数据式离散的，则指出一组值<br>c)如果值的列表是泛指的，则可以采用一个代码表<br>d)对于键或者索引元素，通常包含一个校验位</p>
<p>10)提供某些元素的默认值<br>11)备注区域</p>
<h3 id="5-5-数据存储描述">5.5.数据存储描述</h3><p>1)ID，必须有<br>2)数据存储名<br>3)文件的别名<br>4)简短描述<br>5)文件类型：人工文件或计算机文件<br>6)如果是计算机文件，则文件格式指明是数据库文件，还是传统的平面文件<br>7)文件上记录的最大记录数和平均记录数<br>8)文件或数据名指定的文件名(如果已知)<br>9)数据结构应使用数据字典中的名字，提供与此数据存储的元素的连接</p>
<h3 id="5-6-创建数据字典">5.6.创建数据字典</h3><p>1.先创建DFD，自顶向下开发数据字典和数据流图。可以为每一个层次的DFD创建数据字典。<br><img src="http://i42.tinypic.com/ddp0mh.jpg" alt=""><br>子数据流图上的数据流名称，包含在父过程上的数据流的元素或结构化记录中</p>
<p>2.分析输入输出<br>输入输出分析表包括：<br>1)输入或输出的描述名<br>2)负责进一步澄清细节、设计反馈和最后核准的用户联系信息<br>3)输入数据还是输出数据<br>4)数据流的格式。逻辑DFD，可以处于未确定<br>5)表明报表上或者界面上的数据顺序的元素<br>6)一个元素列表，包括元素的名称、长度，是基本元素还是派生元素，编辑标准。</p>
<p>3.开发数据存储<br>确定永久信息或临时信息。</p>
<h3 id="5-7-使用数据字典">5.7.使用数据字典</h3><p>数据字典可以用来创建界面、报表和表单<br>1.使用数据字典产生计算机语言时要考虑<br>1)输出数据流中的基本元素必须出现在产生该输出数据流过程的输入数据流中。基本元素由键盘输入，而不由某一个过程创建<br>2)派生元素必须由过程创建，并且至少应当由一个不是该元素自身为输入的过程输出<br>3)输入或者输出某个数据存储的数据流中的元素，必须包含在该数据存储中</p>
<p>2.使用数据字典可以创建XML文档<br>XML是一种可用来在企业中交换数据的语言，是一种对数据进行定义、排序、过滤并把它转换成一种每个人都可以使用的统一数据语言的方法。</p>
<div style="color: #EF4808"><br>两个好用的Chrome插件，小伙伴们看完复习资料支持一下吧：<br><a href="https://chrome.google.com/webstore/detail/剪影截图/gkloklemhahnoipikedmafefilidffko" title="剪影截图" target="_blank" rel="external">剪影截图：好用的网页截图，一键人人分享工具，快捷键ctrl+shift+z, 双击确定!</a><br><a href="https://chrome.google.com/webstore/detail/tss下载助手/odhkpoplnhfnhhhkgphckabboemiifle" title="TSS下载助手" target="_blank" rel="external">TSS下载助手：让你方便一键批量下载</a><br></div>

<p>资源：<br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part1/" title="System Analysis and Design (Kenneth Kendall) Review Part1" target="_blank" rel="external">系统分析与设计part1</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part2/" title="System Analysis and Design (Kenneth Kendall) Review Part2" target="_blank" rel="external">系统分析与设计part2</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part3/" title="System Analysis and Design (Kenneth Kendall) Review Part3" target="_blank" rel="external">系统分析与设计part3</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part4/" title="System Analysis and Design (Kenneth Kendall) Review Part4" target="_blank" rel="external">系统分析与设计part4</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.cyanny.com/2013/11/27/system-analysis-design-kenneth-kendall-review-part2/" data-id="cibosbb01000wgprt1sro7okf" class="article-share-link">Share</a>
      
        <a href="http://www.cyanny.com/2013/11/27/system-analysis-design-kenneth-kendall-review-part2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Design/">Design</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Learning/">Learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SystemAnalysis/">SystemAnalysis</a></li></ul>

    </footer>
  </div>
  
</article>


    
      <article id="post-system-analysis-design-kenneth-kendall-review-part1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/27/system-analysis-design-kenneth-kendall-review-part1/">System Analysis and Design (Kenneth Kendall) Review Part1</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2013/11/27/system-analysis-design-kenneth-kendall-review-part1/">
    <time datetime="2013-11-27T02:23:37.000Z" itemprop="datePublished">2013-11-27</time>
  </a>
</div>
          
  <div class="article-category">
  	<i class="fa fa-folder"></i>
    <a class="article-category-link" href="/categories/System-Analysis-and-Design/">System Analysis and Design</a>
  </div>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>系统分析与设计，感觉上是一个需求和软工的大汇总，不温不火，方面很多，只能算是对软件工程的overview。</p>
<h2 id="1-信息收集交互式方法">1.信息收集交互式方法</h2><p>交互式信息收集有：面谈、联合应用程序设计JAD和调查问卷.</p>
<h3 id="1-1_面谈">1.1 面谈</h3><p><strong>1. 面谈的概念</strong><br>面谈是一种面对面的会谈，目的明确，一般采用问答形式。面谈时，需要获取面谈对象的观点，他们对系统当前状态、组织和个人目标、以及非正规过程的感受。[more…]</p>
<ul>
<li>调查面谈对象的观点。</li>
<li>尽力获取面谈对象的感受。</li>
<li>目标是尽力收集重要信息，组织的目标。</li>
<li>面谈也是考察HCI问题的宝贵时机。<br><strong>2.面谈的5各步骤</strong><br>1)阅读背景材料：与面谈对象建立共同词汇<br>2)确定面谈目标：问题中应该有4-6个与HCI、信息处理和决策行为有关。<br>3)决定面谈对象：按层次和影响力选择谈话对象。<br>4)准备面谈对象：打电话或者邮件提前预约<br>5)决定问题的类型和结构：金字塔结构、漏斗结构或者菱形的结构</li>
</ul>
<p><strong>3.问题类型</strong><br><strong>1)开放式问题</strong><br><strong>优点：</strong><br>•让用户谈话自在<br>•可以收集面谈对象使用的词汇，这能反映其教育背景、价值标准、态度和信念<br>•提供丰富的细节，广度<br>•对尚未的进一步的提问方法有启迪作用。<br>•让面谈对象更感兴趣<br>•允许更多的自发性<br>•会见者更容易措辞<br>•在会见者没有准备的紧要关头采用这种类型<br><strong>缺点：</strong><br>•容易不切题，产生太多不相干的细节<br>•时间冗长，花费大量时间才能获得有用的信息<br>•可能会让用户觉得你没有准备，不够专业<br>•留下不好的印象，用户会觉得你在做没有实际意义的调查<br>•后期数据分析较难</p>
<p><strong>2)封闭式问题</strong><br><strong>优点</strong><br>•有针对性，切中要点<br>•能获得准确、贴切的数据<br>•时间上可控，节省时间，可以快速探讨大范围问题。<br>•保持对面谈的控制权<br>•数据分析容易<br><strong>缺点：</strong><br>•让用户厌烦<br>•得不到丰富的细节，失去主要思想<br>•不能建立和面谈对象友好的关系</p>
<p><strong>4.问题结构</strong><br>1)金字塔：先封闭后开放，先具体后一般化，用于用户需要预热，开始拘谨的情况<br>2)漏斗：先一般后具体，适用用户一开始就有激情的情况<br>3)菱形：具体——一般——具体，缺点是费时，优点是：具体的问题开始为面谈做好铺垫，再问一般化问题可以收集丰富的信息，再用具体的问题收尾，为面谈提供了结束的时机。</p>
<h3 id="1-2_JAD联合应用程序设计">1.2 JAD联合应用程序设计</h3><p>由IBM开发，一种一对多的面谈方法，目的是节省个人面谈所需的时间，减少成本；改善信息需求评估结果的质量；通过多方一起参加的过程，获得用户对新信息系统的更多的认可。<br><strong>1.条件</strong><br>•用户时间有限，一对一面谈不行<br>•公司文化允许不同层次的职员间联合问题求解<br>•用户想有点新东西，创新意愿强，而一对一面谈难以得到统一的意见<br>•组织允许关键职员离职2~4天<br><strong>2.涉众：</strong><br>分析员、用户、主管等，<br>一个沟通能力好的主持人<br>8~12位不同阶层的用户<br>需要有两名置身事外的观察员，保证JAD的进行。<br><strong>3.召开会议地点：</strong>一般式2~4天的脱产会议，在远离单位的舒服环境下<br><strong>4.优点</strong><br>•比面谈节省时间<br>•联合协作，可以实现快速软件开发。<br>•改善信息系统所有权的可能性。让用户早日参与系统，获得用户反馈<br>•创造性的开发设计，类似头脑风暴<br><strong>5.缺点</strong><br>•要求所有参与者抽出大块时间，2~4天<br>•任何一方准备不充分，或者后续报告和规范文档没有完成，最终得到的设计会不尽人意<br>•可能还没有充分发展必须得组织技能和组织文化，组织可能还不支持JAD</p>
<h3 id="1-3_问卷调查">1.3 问卷调查</h3><p>问卷调查是一种信息收集技术，它允许系统分析员研究组织中若干关键人物的态度、信念、行为和特征，而这些关键人物可能会受到当前建议系统的影响。<br><strong>1.使用条件</strong><br>•组织成员分布广泛<br>•系统项目涉及许多人<br>•推荐方案之前必须做探索性工作，希望在确定系统项目具体方向之前评估总体意见。<br>•希望在后续的面谈中标识并解决当前系统的所有问题。</p>
<p><strong>2.问题类型</strong><br><strong>1)开放式问题：</strong><br>要估计开发式问题答复的种类，不能太宽泛<br>开放式问题适合想了解公司成员对系统的产品方面，或对系统的过程方面的看法的情况，如果不能有效的列出所有可能的答复，考虑开发式问题。<br>优点：探索性好，广度和深度广，准备问题容易<br>缺点：完成速度慢，分析数据难<br><strong>2)封闭式问题</strong><br>如果要调查大量人员的样本，采用封闭式，数据好统计。<br>如果能有效的列出问题可能的相互排斥的所有答复，采用封闭式问题。<br>优点：完成速度快，分析数据容易<br>缺点：广度和深度窄，准备问题不容易，探索性低</p>
<p><strong>3.措辞的选择</strong><br>使用一致的和企业业务相关的术语<br>•保持措辞简练<br>•使用明确字眼，但避免过度明确问题，如收入等敏感信息<br>•保持问题简短<br>•不要选择低水平的语言，不要用高人一等的口气<br>•避免措辞的偏差<br>•向合适的人发放问卷，不要采用太多专业知识<br>•确保问题中涉及的技术的准确<br>•使用软件检验阅读水平是否合适回答者</p>
<p><strong>4.在问题中的标度的使用</strong><br>定标：为了度量属性或者特征而为他们分配编号或其他符号的过程。<br>1)度量：类别标度，区间标度<br>2)构造定标时要考虑：<br>有效性：度量的内容的程度<br>可靠性：度量的一致性，如果相同条件下两次调查一致，就是外部一致性<br>3)避免的问题<br>不严格的标度：可以把平均水平移到中心的左边或右边来避免<br>集中趋势：回答者都回答中间值，可以通过减少两个端点的差异，调整描述符的强度，创建一个更多结点的尺度来改善<br>光圈效应：避免在一个问题中印象带入下一个问题</p>
<p><strong>5.问卷调查表的设计准则：</strong><br>•留出充足的空白空间<br>•留出充足的空间来填写或输入答复<br>•使回答者能够清楚地标出他们的答复<br>•保持风格的一致<br>•提问顺序的选择：<br>（i）把重要问题放在前面，问题要先人后己，先问用户最关心的问题，再问系统或者调查目的需要的问题<br>（ii）把相似内容的问题放在一起<br>（iii）首先提出非敏感和非争议的问题</p>
<p><strong>6.管理问卷调查表</strong><br>1)回答者：按照调查对象的级别，在公司服务的年限，工作职责和对建议系统的兴趣来选择代表，要选择足够多的代表<br>2)管理调查问卷的方法：<br>a)同时召集所有有关回答者<br>b)亲自发放问卷，并回收<br>c)允许回答者自我处理，并放入中央的箱子里，如web问卷和email问卷，常用的方法，但是回收率可能低<br>d)邮寄给职员，并提供截止日期，填写说明和寄回邮资<br>e)email和web的方式管理</p>
<h2 id="2-_信息收集非干扰性方法">2. 信息收集非干扰性方法</h2><p>包括：采样、调查、观察决策者行为和物理环境</p>
<h3 id="2-1-采样">2.1.采样</h3><p>1. 定义：从某一种群的系统中选择有代表性的个体<br>2. 必要性：节约成本、加快数据搜集过程、提高效率、减少偏差<br>3. 四个步骤</p>
<ul>
<li>确定要收集或要描述的数据：考虑数据收集方法（调查、面谈、调查问卷和观察等），考虑研究目标</li>
<li>确定采样种群：硬数据（两个月或全年的报表），采样的客户</li>
<li>选择采样类型</li>
<li><p>决定采样规模<br>4. 采样类型：<br>1) 便利采样：容易安排，五约束的非概率型采样，最不可靠<br>2) 目的采样：选择对系统了解，感兴趣的人，这是非概率型采样，只有适度的可信度<br>3) 简单随机采用：每个个体的机会相同，产生一个随机编号表，在文档和报表采用中不切实际。<br>4) 复杂采样是最好的</p>
</li>
<li><p>系统采样：在名单中每个K个人选择一个，缺点是存在周期问题，引入偏差，采样大量不成比例的职员</p>
</li>
<li>分层采样：最重要的方式，在不同的层次，如管理层，社会阶层，在不同层次中按比例选择。当想对不同层次用户采用不同数据收集方法时采用分层采样。</li>
<li>聚类采样：选择一组人或文档进行研究</li>
</ul>
<p>5.  采样规模<br>1)  确定采样属性<br>2)  定位能查找到的属性的数据库或报表<br>3)  分析属性，估计p，一般取0.1或0.5<br>4)  主观是定一个值，i 作为区间估计<br>5)  选择置信度 z，如 95%时 z=1.96<br>6)  计算种群比例的标准差  σ=i/z<br>7)  计算采样规模：n=(p(1-p))/σ^2  + 1<br>置信度越高采样规模越大<br>确定面谈时的采样规模： 至少与组织中每个阶层的3个人进行面谈，3个人种至少有一个来自组织中的不同部门。</p>
<h3 id="2-2_调查">2.2 调查</h3><p>调查法：发现数据并对数据进行分析的行为。需要研究不同的硬数据。</p>
<h4 id="2-2-1_分析定量文档">2.2.1 分析定量文档</h4><p>1.用于决策的报表<br>通常是与库存状态、销售量和生产有关的纸质报表<br>生产报表：包括最近价格、当前库存、最近劳动力和设备等信息<br>总结报表：提供公司的背景和战略信息</p>
<p>2.业绩报表： 估计实际业绩和预期业绩的差距</p>
<p>3.记录<br>a)检查数量和总数的错误。<br>b)寻找改善记录表格设计的机会<br>c)观察交易的数目的类型<br>d)寻求能用计算机简化工作的实例（即，计算和其他数据处理）</p>
<p>4.数据收集表格：有助于理解企业的信息流<br>a)收集所有正在使用的表格样品<br>b)标出表格类型：内部，手写，web表等<br>c)记录打算采用的分发方式<br>d)将打算采用的分发方式和实际收到表格的人做比较<br>数据收集表格的分析耗时，还可以对已经填好的数据表格进行采样，需要记住5个问题：<br>•表格填写完整了么？缺了什么<br>•有从未使用过的表格么？为什么？<br>•所有表格都向相应地人做了详细说明么？没有，为什么？<br>•如果有纸质的表格，和web表格，比较填写速度<br>•经常使用非官方的表格么？</p>
<h4 id="2-2-2_分析定性文档">2.2.2 分析定性文档</h4><p>电子邮件、备忘录，留言板、工作区的签名、web页面、程序指南和战略手册<br><strong>5个指导原则：</strong><br>•检查文档中的关键比喻或主导比喻<br>•在文档中寻找局内人与局外人或“我们反对他们”的思想状况<br>•列出褒义或贬义的术语，文档中重复出现的术语<br>•查找在公共区域Web页面上公布的有意义的图形、标识语和图标的用法。<br>•识别出幽默感。</p>
<p>1.备忘录： 了解组织成员对价值、态度和信念的看法<br>2. 公告板或者工作区的标语与海报：体会公司的主流文化<br>3. 公司中的Web站点：分析网站内容的比喻、幽默和使用的特性（颜色、图形、动画和超级链接），从技术、美学和管理方面调查。 调查web站点和站点间的交互性、消息的可访问性和明显的安全性<br>4. 指南：程序指南和在线指南，指南很少会保持更新<br>5. 政策手册：价值观、态度和信念。<br>老师说不考但是上课说道物理环境，也是调查的一部分：办公设备、布置、公司文化，楼层安排，布告栏，email 论坛，公司色调。</p>
<h2 id="3-_原型化方法">3. 原型化方法</h2><h3 id="3-1_原型化方法">3.1 原型化方法</h3><p>1. 原型：是实际运行的有产品的主要特征，基于软件最初版本的演习。不需要反映所有的功能，只需有软件功能的子集。<br>原型化方法是通过原型来获取有关建议系统和系统如何迅速满足用户信息需求的反馈的极好办法。<br>2. 原型分类一：<br>水平原型：多种功能的展示<br>垂直原型：对某一个功能进行详细展示</p>
<p>3.原型分类二(书中的分类)<br>•拼凑原型：构件一个可以运行，但又是经过修补或者拼凑而得到的系统。<br>•非操作原型：为了试验设计方案的某些方面而建立的一个非工作比例模型。如汽车实物模型。当编码成本高时采用<br>•系列首发原型：创建系统的第一个实物工作模型，即试验模型，是可以工作的原型。<br>•精选特征原型：建立一个包含最终系统部分特性而不是全部特性的可工作模型。</p>
<p>4.原型分类三<br>•抛弃式原型：尽可能快速开发<br>•试用型原型：最终的开发平台和原型相同<br>•试验型原型：最终开发平台与原型不同。</p>
<p>5.原型化方法的优点<br>•根据用户反馈，不断调整修改<br>•开发周期短，成本低<br>•缩短产品和需求的差别，开发出更贴近用户需求和期望的系统<br>•界面原型在获取用户反馈时有很大优势<br>•可以在系统开发早期改变系统<br>•可以中止一个不能工作的系统开发</p>
<p>6.原型化方法的缺点：<br>•需求不充足，开发者对用户需求不清楚，误解，过早的形成一个系统<br>•原型和最终系统之间存在差别，用户会误以为是最终系统<br>•开发者容易依赖原型，不愿意放弃原型<br>•原型开发成本高时会过度占用开发周期宝贵的时间，最初原型不能超过20%的时间<br>•经济损耗</p>
<p>7.原型化方法不适用的地方：<br>嵌入式系统：界面简单，与硬件太接近，需求明确<br>实时控制软件：搜索引擎，<br>科学计算：matlab，因需求明确，精度，效率，时间要求明确，模块太多，重要性均等，无法明确判定哪些是重要的需要原型化的。<br>但是很多应用，如游戏是适用于原型开发的。</p>
<h3 id="3-2_原型开发">3.2 原型开发</h3><p>1. 原型化方法的要求：<br>用户是熟练的专家，可以给出反馈<br>重视界面，如手持设备<br>成本低，不会占用太长的开发周期</p>
<p>2.开发准则<br>•引进便于管理的模块：但不用建立完整的工作准则<br>•快速建立原型<br>•用连续迭代来修改原型<br>•强调用户界面：用户可以和原型轻松交互</p>
<p>3.原型开发流程<br>听取用户意见，修改原型，用户测试，不断循环迭代。</p>
<h3 id="3-3_RAD快速应用程序开发">3.3 RAD快速应用程序开发</h3><p>1. 定义：是一种面向对象的系统开发方法，包括开发方法和开发工具。目标是缩短传统SDLC方法中信息系统的设计和实践之间漫长的时间，反映需求的变更，是原型化方法的一种特殊实现。</p>
<p>2. RAD的阶段<br><img src="http://i39.tinypic.com/zjv0nb.jpg" alt=""><br>1)需求规划阶段：确定系统的业务目标和信息需求<br>2)RAD设计研讨会：RAD的核心，与用户共同合作设计系统，讨论设计的非技术方面，并对构建的工作原型给出反馈<br>3)实现阶段：根据设计，建立、优化、测试新系统</p>
<p>3. Jame Martin RAD 四个阶段<br><img src="http://i40.tinypic.com/292bkaq.jpg" alt=""><br>1)需求规划：高级用户决定系统的功能<br>2)用户设计：与用户交互讨论系统的非技术方面<br>3)构建阶段：根据设计，用RAD工具构建，并向用户展示新系统，让他们交互、评论和检查。<br>4)转换阶段：新系统取代旧系统，测试新系统，培训用户</p>
<p>4.优势<br>•传统SDLC采用的是有序的、系统的开发方法，保证系统的完整性和精确性，<br>但抵制变更，不能很好地处理需求的变更。<br>•RAD缩短SDLC，更欢迎变更。</p>
<p>5.使用条件<br>•团队中有用过RAD的程序员和分析员<br>•由于商业压力，要求加快应用程序某部分的开发<br>•从事一项全新的电子商务应用程序，并且开发团队相信，如果应用程序是第一个或第一批出现在web上，则企业作为一个创新者取得竞争优势。<br>•用户经验丰富，对公司的组织目标高度负责。</p>
<p>6.缺点：缺乏文档</p>
<div style="color: #EF4808"><br>两个好用的Chrome插件，小伙伴们看完复习资料支持一下吧：<br><a href="https://chrome.google.com/webstore/detail/剪影截图/gkloklemhahnoipikedmafefilidffko" title="剪影截图" target="_blank" rel="external">剪影截图：好用的网页截图，一键人人分享工具，快捷键ctrl+shift+z, 双击确定!</a><br><a href="https://chrome.google.com/webstore/detail/tss下载助手/odhkpoplnhfnhhhkgphckabboemiifle" title="TSS下载助手" target="_blank" rel="external">TSS下载助手：让你方便一键批量下载</a><br></div>

<p>资源：<br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part1/" title="System Analysis and Design (Kenneth Kendall) Review Part1" target="_blank" rel="external">系统分析与设计part1</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part2/" title="System Analysis and Design (Kenneth Kendall) Review Part2" target="_blank" rel="external">系统分析与设计part2</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part3/" title="System Analysis and Design (Kenneth Kendall) Review Part3" target="_blank" rel="external">系统分析与设计part3</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part4/" title="System Analysis and Design (Kenneth Kendall) Review Part4" target="_blank" rel="external">系统分析与设计part4</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.cyanny.com/2013/11/27/system-analysis-design-kenneth-kendall-review-part1/" data-id="cibosbb070011gprtyiarvr7v" class="article-share-link">Share</a>
      
        <a href="http://www.cyanny.com/2013/11/27/system-analysis-design-kenneth-kendall-review-part1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Design/">Design</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Learning/">Learning</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SystemAnalysis/">SystemAnalysis</a></li></ul>

    </footer>
  </div>
  
</article>


    
      <article id="post-distributed-system-review-part4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/24/distributed-system-review-part4/">分布式系统总结part4</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2013/11/24/distributed-system-review-part4/">
    <time datetime="2013-11-24T07:04:39.000Z" itemprop="datePublished">2013-11-24</time>
  </a>
</div>
          
  <div class="article-category">
  	<i class="fa fa-folder"></i>
    <a class="article-category-link" href="/categories/Distributed-System/">Distributed System</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Distributed-System/Life/">Life</a>
  </div>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Petri网">Petri网</h3><h4 id="1-_以生产者消费者为例子">1. 以生产者消费者为例子</h4><p>Petri三元组PN=(P,T,F)即，库所，变迁，转换弧</p>
<p>Preset表示前集,如果x是变迁，那么preset表示某个变迁的输入库所集合，如果x是某个库所那么preset表示某个库所的输入变迁。</p>
<p>Postset表示后集，如果x是变迁，那么postset表示某个变迁的输出库所集合，如果x是库所，那么postset表示某个库所的输出变迁集合。[more…]<br><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System14.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System14-580x398.png" alt="Distributed System14"></a></p>
<h4 id="2-_Marking，_Enable，_Firing">2. Marking， Enable， Firing</h4><p>M(p)表示当前所有库所的Token数量, 是一个快照.<br><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System16.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System16-580x290.png" alt="Distributed System16"></a><br>通过这个图，可以很简单地看出 M(p)的计算等式.<br>当库所的token都到位后，变迁就enable了，如上图左边t2是enable的, t1没有enable， 如果Firing点火，就会转到另一个Marking下，如图中右边的图是点火后的Marking。</p>
<h3 id="3-Handle">3.Handle</h3><p>PP—handled : 某一个Place到另一个Place有两条不相交的路径</p>
<p>TT handled：某一个Transition和另一个Transition有两条不相交的路径</p>
<p>PT—handled：某一个Place到另一个Transition有两条不相交的路径</p>
<p>TP—handled：某一个Transition到另一个Place有两条不相交的路径</p>
<p>Well-handled：只有TT和PP，没有PT，TP。 因为PT会有死锁的风险， TP会造出某一个Place内部的Token无限增长</p>
<h3 id="4-State_Machine和Marked_Graph">4.State Machine和Marked Graph</h3><p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System17.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System17-580x349.png" alt="Distributed System17"></a></p>
<ul>
<li>Marked Graph：库所只有单个输入和单个输出</li>
<li>State Machine: 每个变迁只有单个输入和单个输出，这是一个有限状态机</li>
<li>T-component：如果一个大的Petri可以找到一个子网符合marked graph的要求，就是 T-component, 如果所有的T-component的集合可以覆盖整个Petri网，就是T-coverability。</li>
<li>P-component：是一个大的网络中的一个Petri子网，满足state machine的，如所有的P-component可以覆盖整个Petri网，则称Petri网P-coverability</li>
</ul>
<h3 id="5-_活性和有界性">5. 活性和有界性</h3><ul>
<li>活性：从M0状态出发，对于任何一个M和t转换后的M’，可以让任何变迁T有可能点火enable.什么是不活呢，就是死锁，但是不死锁，不等价于活性</li>
<li>有界性：不论状态如何变化，token数量都不会无限增长，保持在一定数量</li>
<li>Petri是well-formed的：存在M0使这个Petri网有活性并且有界</li>
</ul>
<h3 id="6-_Free-choice_structure">6. Free-choice structure</h3><p>自由选择结构：如果两个输入库所交集不为空，蕴含两个输入库所相等</p>
<p>t1和t2是对等的选择关系.</p>
<p>自由选择结构可以表达并发关系和同步关系</p>
<p>给定一个自由选择结构，可以很好地决定它的活性和有界性。</p>
<h3 id="7-_哲学家吃通心粉">7. 哲学家吃通心粉</h3><p>有五个哲学家围坐在一圆桌旁，桌子中央有一盘通心面，每人面前有一只空盘子，每两人之间放一把叉子。每个哲学家思考、饥饿、然后，欲吃通心面。为了吃面，每个哲学家必须获得两把叉子，且每人只能直接从自己左边或右边去取叉子。</p>
<p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System15.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System15-580x355.png" alt="Distributed System15"></a></p>
<h3 id="资源">资源</h3><p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part1/" title="分布式系统总结part1" target="_blank" rel="external">分布式系统总结part1 中间件，进程迁移，移动通信失效，名称解析，移动实体定位</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part2/" title="分布式系统总结part2" target="_blank" rel="external">分布式系统总结part2 Lamport同步与向量时间戳，两大选举算法，三大互斥算法</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part3/" title="分布式系统总结part3" target="_blank" rel="external">分布式系统总结part3 复制和一致性(以数据和以客户为中心的一致性)，容错（拜占庭将军问题，两阶段与三阶段提交）</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part4/" title="分布式系统总结part4" target="_blank" rel="external">分布式系统总结part4 Petri网解决哲学家问题和生产者、消费者问题</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.cyanny.com/2013/11/24/distributed-system-review-part4/" data-id="cibosbb46005ggprt4qwmth4m" class="article-share-link">Share</a>
      
        <a href="http://www.cyanny.com/2013/11/24/distributed-system-review-part4/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Learning/">Learning</a></li></ul>

    </footer>
  </div>
  
</article>


    
      <article id="post-distributed-system-review-part3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/24/distributed-system-review-part3/">分布式系统总结part3</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2013/11/24/distributed-system-review-part3/">
    <time datetime="2013-11-24T06:26:20.000Z" itemprop="datePublished">2013-11-24</time>
  </a>
</div>
          
  <div class="article-category">
  	<i class="fa fa-folder"></i>
    <a class="article-category-link" href="/categories/Distributed-System/">Distributed System</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Distributed-System/Life/">Life</a>
  </div>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="复制和一致性">复制和一致性</h2><p>数据的复制是为了提高性能和可靠性，但是我们需要保持各个副本的一致性：</p>
<p>问题一： 数据更新的实际分发问题，它需要关心副本的位置，以及如何在副本之间传播更新。</p>
<p>问题二：如何保持多个副本的一致性[more…]</p>
<h3 id="以数据为中心的一致性">以数据为中心的一致性</h3><h4 id="1-_严格的一致性">1. 严格的一致性</h4><p>(1)条件：所有访问按绝对时间排序，数据项x的任何读操作将返回最近一次对x的写操作的结果所对应的值。</p>
<p>(2)要求：所有写操作是瞬间可见的，系统维持一个绝对的全局时间顺序，如果发生写操作，后续的读操作都会得到最新的写入的值。</p>
<p>(3)缺点：依赖于绝对的全局时间，分布式系统中为每个操作分配准确的全局时间是不可能的，一般是将时间分割成一系列连续的、不重叠的时间间隔，保证没个时间间隔内最多只发生一个单一操作。<br>精确的定义最后一次写操作是困难的，如图可以看到严格一致性<br><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System02.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System02.png" alt="Distributed System02"></a></p>
<h4 id="2-线性化和顺序的一致性">2.线性化和顺序的一致性</h4><p>(1)顺序一致性</p>
<p>条件：所有进程以相同顺序看到所有的共享访问，访问不按时间排序。任何执行结果都是相同的，就好像所有进程对数据存储的读、写操作按照某种序列顺序执行的，并且每个进程的操作按照程序所定制的顺序出现在这个序列中。</p>
<p>缺点：严重的性能问题，对于任何的顺序一致性存储，改变协议以提高读操作的性能必将降低写操作的性能，反之亦然。<br><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System03.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System03-580x350.png" alt="Distributed System03"></a><br>(2)线性化一致性</p>
<p>条件：所有进程以相同顺序看到所有的共享访问，访问根据(并非唯一的)全局时间戳排序。</p>
<p>在实际应用中，线性化主要用于开发算法的形式验证。关于根据时间戳维护顺序的附加限制使得线性化的实现比顺序一致性的实现开销更大。 </p>
<h4 id="3-因果一致性">3.因果一致性</h4><p>条件：是一种弱化的顺序一致性模型，所有进程必须以相同的顺序看到具有潜在因果关系的写操作。不同机器上的进程可以以不同的顺序被看到并发的写操作.</p>
<p>当一个读操作后面跟着一个写操作时，这两个事件就具有潜在的因果关系。</p>
<p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System04.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System04-580x394.png" alt="Distributed System04"></a></p>
<h4 id="4-FIFO一致性">4.FIFO一致性</h4><p>条件：所有进程以某个单一进程(有两个以上的写操作)提出写操作的顺序看到这些写操作，但是不同进程可以以不同的顺序看到不同的进程提出的写操作。</p>
<p>优点：容易实现，不需要保证不同进程看到相同的写操作顺序，除非两个以上的写操作是同一个进程提出的。这种情况下，写操作必须按顺序达到。</p>
<p>缺点：仍然对许多应用存在不必要的限制，因为这些应用需要从任何位置都可以看到按顺序看到某个单一进程所产生的写操作。同时并不是所有的应用程序都要求看到所有的写操作。这就引入了弱一致性。</p>
<p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System05.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System05.png" alt="Distributed System05"></a></p>
<h4 id="5-弱一致性">5.弱一致性</h4><p>条件：引入同步变量，只有执行一次同步，共享数据才能保持一致。  </p>
<p>a)对数据存储所关联的同步变量的访问是顺序一致的；b)每个拷贝完成所有先前执行的写操作之前，不允许对同步变量进行任何操作；c)所有先前对同步变量执行的操作都执行完毕之前，不允许对数据项进行任何读或者写操作。</p>
<p>特点：弱一致性是在一组操作，而非单个操作上强迫执行顺序一致性。同步变量用于划分操作的组。</p>
<p>缺点：即当同步变量被访问时，数据存储不知道此次访问是因为进程已经结束对数据存储的写操作还是因为进程将开始读数据而进行的。我们需要区分进程进入临界区和离开临界区的区别，引入了释放一致性。 </p>
<p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System06.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System06-580x347.png" alt="Distributed System06"></a></p>
<h4 id="6-释放一致性">6.释放一致性</h4><p>条件：退出临界区时，让共享数据保持一致，提供两种类型的同步变量。获取(acquire) 操作是用于通知数据存储进程进入临界区的操作，而释放(release)操作是表明进程刚刚离开临界区的操作。</p>
<ul>
<li>对共享数据执行读操作或写操作之前，所有进程先前执行的获取操作都必须已经成功完成；</li>
<li>在释放操作被允许执行前，所有进程先前执行的读操作和写操作都必须已经完成；</li>
<li>对同步变量的访问是FIFO一致的(不需要顺序一致)</li>
</ul>
<p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System07.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System07.png" alt="Distributed System07"></a></p>
<h4 id="7-入口一致性">7.入口一致性</h4><p>条件：它需要程序员(或编译器)在每个临界区的开始和结束处分别使用获取和释放操作，入口一致性要求每个普通的共享数据项都要与某种同步变量(如锁或障碍)关联。即让进程在进入临界区时，让属于同一临界区的共享数据保持一致。</p>
<p>优点：第一，将一系列共享数据项与各自的同步变量关联起来可以减少获取和释放一个同步变量所带来的额外开销。因为只有少数的数据项需要同步。第二，增加了并行度：这也使得多个包含不同共享数据的临界区可以同时执行</p>
<p>缺点：第一，同步变量和共享数据的关联带来了额外的复杂性和负载，程序设计可能更加复杂，容易出错。第二，关于入口一致性的一个程序设计问题是如何正确地将数据与同步变量关联起来。解决这个问题的一种方法是使用分布式的共享对象，向用户屏蔽低层的同步细节。</p>
<h4 id="以数据为中心的一致性的比较">以数据为中心的一致性的比较</h4><p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System18.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System18-580x276.png" alt="Distributed System18"></a><br><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System19.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System19-580x222.png" alt="Distributed System19"></a></p>
<h3 id="以客户为中心的一致性模型">以客户为中心的一致性模型</h3><h4 id="1-_最终一致性">1. 最终一致性</h4><p>条件： 没有更新操作时，所有副本逐渐成为相互完全相同的拷贝。最终一致性实际上只要求更新操作被保证传播到所有副本</p>
<p>优点：开销小</p>
<p>缺点：移动用户访问分布式数据库的不同副本时，如果副本没有更新，会出现不一致。</p>
<h4 id="2-_单调读">2. 单调读</h4><p>条件：总是读最新值，如果一个进程读取数据x的值，那么该进程对执行任何后续读操作将总是得到第一次读取的那个值或更新的值。<br>如果一个进程已经在t时刻看到x的值，那么以后他不再会看到较老的版本的x的值。</p>
<p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System08.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System08-580x359.png" alt="Distributed System08"></a></p>
<h4 id="3-_单调写">3. 单调写</h4><p>条件：总是在最新的拷贝上写，一个进程对数据项x执行的写操作必须在该进程对x执行任何后续写操作之前完成，保证写操作以正确的顺序传播到数据存储的所有拷贝。<br>在单调写一致性的定义中，同一进程的写操作的执行顺序与这些操作的启动顺序相同。</p>
<p>比较：注意，单调写一致性与数据为中心的FIFO一致性相似。FIFO一致性的本质是，同一进程执行的写操作必须在任何地方以正确的顺序执行。</p>
<p>这一顺序限制也适用于单调写一致性，只是我们这里考虑的是仅为单一进程维持的一致性，而不是为许多并发进程维持的一致性。</p>
<p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System09.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System09-580x382.png" alt="Distributed System09"></a></p>
<h3 id="4-写后读">4.写后读</h3><p>条件：一个进程对数据项x执行一次写操作的结果总是会被该进程对x执行的后续读操作看见。 一个写操作总是在同一进程执行的后续读操作之前完成，而不管这个后续的读操作发生在什么位置。 </p>
<p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System10.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System10-580x344.png" alt="Distributed System10"></a></p>
<h3 id="5-读后写">5.读后写</h3><p>条件：同一个进程对数据项x执行的读操作之后的写操作，保证发生在与x读取值相同或比之更新的值上。进程对数据项上x所执行的任何后续的写操作都会在x的拷贝上执行，而该拷贝是用该进程最近读取的值更新的。</p>
<p>在读取的最新值上进行写操作。<br><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System11.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System11-580x340.png" alt="Distributed System11"></a></p>
<h2 id="容错">容错</h2><h3 id="1-_两军问题">1. 两军问题</h3><p>两军的通信信道不稳定，需要达成一致才能发动攻击，无论双方发了多少次确认，都不能确定通信兵是否把自己的消息带给对方，永远不会达成协议。<br>在不可靠传输的条件下，即使是无错误的进程，在两个进程之间达成协议也是不可能的。</p>
<h3 id="2-_拜占庭将军问题">2. 拜占庭将军问题</h3><p>通信良好，进程确不好，正如拜占庭的将军有叛徒的情况。</p>
<p>在这个问题中，红军还是在山谷中扎营，但是在附近的山上有n个带领部队的蓝军将领。通信是通过电话双向进行的，及时而且质量很好。但是有n个将军是叛徒(故障)，他们通过给忠诚的将军发送错误的和矛盾的信息(模拟故障进程)来阻止他们达成协议。现在问题在于忠诚的将军是否还能达成协议。 </p>
<p>Lamport采用递归算法来让无故障的进程达成协议。</p>
<p>N个进程，其中M个故障进程：只有当<strong>N&gt;=3m+1</strong>时，才能达成一致，即有三分之二的进程是正常的。</p>
<h3 id="3-_两阶段提交">3. 两阶段提交</h3><p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System12.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System12-580x293.png" alt="Distributed System12"></a><br>状态机很能说明问题。</p>
<p>两个阶段：vote_commit and global_commit, 3(n-1)条消息</p>
<p>缺点：两阶段提交的一个问题在于当协调者崩溃时，参与者不能做出最后的决定。因此参与者可能在协调者恢复之前保持阻塞。</p>
<p>因此引入3PC，三阶段提交，但3PC实际中用的少，因为2PC阻塞情况很少出现。</p>
<h3 id="4-_三阶段提交">4. 三阶段提交</h3><p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System13.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System13-580x302.png" alt="Distributed System13"></a><br>没有一个可以直接转换到Commit或者Abort状态的单独状态。</p>
<p>没有一个这样的状态：它不能做出最后决定，而且可以从它直接转换到Commit状态。 Commit之前需要经过PRCOMMIT状态。</p>
<p>三阶段：vote-commit, prepare-commit, global-commit</p>
<p>引入了PRECOMMIT状态。</p>
<ul>
<li>2PC：崩溃的参与者可能恢复到了Commit状态而所有参与者还处于Ready状态。在这种情况下，其余的可能操作进程不能做出最后的决定，不得不在崩溃的进程恢复之前阻塞。</li>
<li>在3PC中，只要有可操作的进程处于Ready状态，就没有崩溃的进程可以恢复到Init、Abort或Precommit之外的状态。因此存活进程总是可以做出的最后决定。当协调者崩溃，达到了预备提交阶段，在2PC中其他进程就会阻塞，但在3PC中，在预备提交阶段，即使没有协调者，也可以做出决定。</li>
</ul>
<h3 id="资源">资源</h3><p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part1/" title="分布式系统总结part1" target="_blank" rel="external">分布式系统总结part1 中间件，进程迁移，移动通信失效，名称解析，移动实体定位</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part2/" title="分布式系统总结part2" target="_blank" rel="external">分布式系统总结part2 Lamport同步与向量时间戳，两大选举算法，三大互斥算法</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part3/" title="分布式系统总结part3" target="_blank" rel="external">分布式系统总结part3 复制和一致性(以数据和以客户为中心的一致性)，容错（拜占庭将军问题，两阶段与三阶段提交）</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part4/" title="分布式系统总结part4" target="_blank" rel="external">分布式系统总结part4 Petri网解决哲学家问题和生产者、消费者问题</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.cyanny.com/2013/11/24/distributed-system-review-part3/" data-id="cibosbb4b005mgprtdk9xkzub" class="article-share-link">Share</a>
      
        <a href="http://www.cyanny.com/2013/11/24/distributed-system-review-part3/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Learning/">Learning</a></li></ul>

    </footer>
  </div>
  
</article>


    
      <article id="post-distributed-system-review-part2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/24/distributed-system-review-part2/">分布式系统总结part2</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2013/11/24/distributed-system-review-part2/">
    <time datetime="2013-11-24T05:19:34.000Z" itemprop="datePublished">2013-11-24</time>
  </a>
</div>
          
  <div class="article-category">
  	<i class="fa fa-folder"></i>
    <a class="article-category-link" href="/categories/Distributed-System/">Distributed System</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Distributed-System/Life/">Life</a>
  </div>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Lamport逻辑和向量时间戳">Lamport逻辑和向量时间戳</h3><p><strong>1.Lamport逻辑时钟</strong></p>
<p>Lamport认为，重要的不是所有进程在时间上完全一致，而是它们在事件的发生顺序上要达成一致。</p>
<p>先发生的定义： a → b 表示a在b之前发生，此时 C(a) &lt; C(b), a b可以是同一个进程中的两个事件或进程间的消息发送事件。并发事件没有先后关系。</p>
<p>Lamport算法：[more…]</p>
<ul>
<li>遵循事件的先发生关系，每个消息都应携带根据发送者时钟的发送时间，当消息到达并接收时，接收者时钟显示的时间比消息发送者时间早时，接收者就将时钟调到比发送者者的时间大1的值。</li>
<li>为了满足全局时间的需要：在每两个事件之间，时钟必须至少滴答一次，如果一个进程以相当快的速度发送或者接收两个消息，那么他得时钟必须在这之间至少滴答一次。</li>
<li>两个事件不会精确地同时发生</li>
</ul>
<p><strong>2.Lamport逻辑时钟的缺陷</strong></p>
<p>不能捕捉因果关系，而向量时间戳可以。</p>
<ul>
<li>Lamport时间戳导致分布式系统中所有事件都要经过排序以具有这样的关系：如果a发生在b之前， 那么C(a) &lt; C(b)</li>
<li>Lamport时间戳只能捕捉事件发生的先后关系，而不能捕捉因果关系。C(a) &lt; C(b)不能说明a事件发生在b事件之前。 因果关系需要通过向量时间戳来捕获。</li>
</ul>
<p><strong>3.向量时间戳</strong></p>
<p>因果关系：如果VT(a) &lt; VT(b) 则a在因果上处于事件b之前。向量时间戳是让每个进程P都维护一个向量V来完成，该向量的性质如下：</p>
<p>a)Vi[i]是到目前为止进程Pi发生的事件的数量。 </p>
<p>b)如果Vi[j]=k，那么进程Pi知道进程Pj中已经发生了k个事件</p>
<p>接收者可以通过消息m的时间戳知道其他进程中有多少事件发生在它之前，消息m在因果上可能依赖于这些事件。</p>
<p>当Pj收到消息m，调整自己的向量，将每项Vj[k]设置为<strong>max{Vj[k], vt[k]}</strong>, 然后  <strong>Vj[i]增加1</strong>。</p>
<p>需要会看图计算向量时间戳：<br><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System01.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System01-580x308.png" alt="Distributed System01"></a><br>向量时间戳中只有各个分量都是小于关系时存在因果关系，而平行关系是并发关系。</p>
<h3 id="选举算法">选举算法</h3><p><strong>1. 欺负算法(Bully Algorithm)</strong></p>
<p>算法：当一个进程发现协调者不再响应请求时，它就发起一个选举：</p>
<p>P向所有编号比它大的进程发送一个election消息； </p>
<p>如果无人响应，P获胜成为协调者； </p>
<p>如果有编号比它大的进程响应，则响应者接管选举工作。P的工作完成。</p>
<p>当以前崩溃的进程恢复时，它将主持一次选举，如果该进程是当前正在运行的进程中进程号最大的，就成为协调者。</p>
<p>总之进程号最大的总是取胜。</p>
<p><strong>2.环算法——不使用令牌环</strong></p>
<p>假设进程按照物理和逻辑顺序进行了排序，那么每个进程就知道它的后继者是谁了。</p>
<p>当任何一个进程注意到协调者不工作时，它就构造一个带有它自己的进程号的election消息，并将该消息发送给它的后继者。</p>
<p>如果后继者崩溃了，发送者沿着此环跳过它的后继者发送给下一个进程，或者再下一个，直到找到一个正在运行进程。</p>
<p>在每一步中，发送者都将自己的进程号加到该消息列表中，以使自己成为协调者的候选人之一。 </p>
<p>最终，消息返回到发起此次选举的进程。当发起者进程接收到一个包含自己进程号的消息时，它识别出这个事件。此时，消息类型变成coordinator消息，并再一次绕环运行，向所有进程通知谁是协调者(成员列表中进程号最大的那个)以及新环中的成员都有谁。这个消息再循环一周后被删除，随后每个进程都恢复原来的工作。</p>
<h3 id="互斥算法">互斥算法</h3><h4 id="1-_集中式算法">1. 集中式算法</h4><p>(1).算法</p>
<p>选举一个进程作为协调者，如最大网络地址号的机器上的进程。</p>
<p>无论何时一个进程要进入临界区，它都要向协调者发送一个请求消息，说明它想要进入哪个临界区并请求允许。</p>
<p>如果没有进程在临界区就发送“允许”应答，该进程进入临界区，如果有进程在临界区，就把该消息放入请求队列，发送“拒绝请求”的应答。</p>
<p>当临界区中的进程退出临界区，向协调者发送“释放”消息，协调者会从请求队列中取出第一个进程，发送“允许”进入的消息。</p>
<p>(2)优点</p>
<p>实现了互斥，每个时刻，协调者只让一个进程进入临界区。</p>
<p>很公平，没有进程会永远阻塞，不会饥饿，不会死锁</p>
<p>容易实现，每使用一次临界区，只需要三条消息（请求，允许，释放）</p>
<p>可以管理临界区或更一般的资源<br>(3).缺点</p>
<p>协调者是单点故障，在规模较大的系统中，单个协调者会成为性能瓶颈.</p>
<p>如果进程在发出请求之后阻塞，那么请求者就不能区分“拒绝进入”和协调者已经崩溃的两种情况。</p>
<h4 id="2-分布式算法">2.分布式算法</h4><p>1)Lamport算法</p>
<ul>
<li>当进程Si想进入临界区，向其他n-1个进程广播请求REQUEST(tsi, i), 并把请求放入自己请求队列request_queuei。</li>
<li>其他n-1个进程受到请求REQUEST(tsi, i)后，把该请求放入各自的请求队列request_queuej， 并向进程Si响应一个带时间戳的REPLY消息。</li>
<li><p>进程Si进入临界区，当且仅当满足以下两个条件：</p>
<pre><code>*   Si从其他进程收到的消息的时间戳都大于自己的请求时间戳<span class="comment">(tsi, i)</span>
</code></pre><ul>
<li>Si的请求是请求队列request_queuei的第一个请求</li>
</ul>
</li>
<li><p>当进程Si退出临界区：从请求队列request_queuei中删除该请求，并向其他n-1个进程广播一个带时间戳的释放临界区的消息。其他n-1个进程收到该消息后，从请求队列request_queuej中删除该请求</p>
</li>
</ul>
<p>在Lamport算法中，进程Request, REPLY, RELEASE一共发送了3(n-1)条消息，其实在一个接收者收到消息后，如果不同意Si进入临界区，没有必要再发送确认。<br>可以改进算法在2(n-1)到3(n-1)之间</p>
<p>2)Ricart和Agrwala算法，改进Lamport算法</p>
<ul>
<li>当一个进程想进入一个临界区时，它构造一个消息，其中包含它要进入的临界区的名字、它的进程号和当前时间。然后它将消息发送给所有其他的进程，理论上讲也包括它自己。</li>
<li>当一个进程接收到来自另一个进程的请求消息时，它根据自己与消息中的临界区相关的状态来决定它要采取的动作。可以分为三种情况：第一，若接收者不在临界区也不想进入临界区，它就向发送者发送一个OK消息。第二，若接收者已经在临界区，它不进行应答，而是将该请求放入队列中。第三，如果接收者想进入临界区但尚未进入时，它将对收到的消息的时间戳和包含在它发送给其余进程的消息中的时间戳进行比较。时间戳最早的那个进程获胜。如果收到的消息的时间戳比较早，那么接收者向发送者发回一个OK消息。如果它自己的消息的时间戳比较早，那么接收者将接收到的请求放入队列中，并且不发送任何消息。</li>
<li>在发送了请求进入临界区的请求消息后，进程进行等待，直到其他所有进程都发回OK消息为止。一旦得到所有进程的允许，它就可以进入临界区了。当它退出临界区时，它向其他队列中的所有进程发送OK消息，并将请求从队列中删除。（也就是说一个进程进入临界区的条件是收到了n-1个OK消息）</li>
</ul>
<p>算法优点：不会饥饿，死锁；每次进入临界区仅需要2(n-1)条消息；没有单点故障</p>
<p>算法缺点：第一，单点故障变成了n点故障，如果任何一个进程崩溃，不能应答OK，这种不应答被错误的解释为拒绝请求，阻塞了所有进程进入任何一个临界区。第二，网络通信开销多于集中式算法；第三，要么必须使用组通信原语，要么每个进程必须维护组成员清单；第四，要求所有进程参与做出与进入临界区有关的所有决定，强迫每个进程都承担这样的负载是不可能的，可以在得到大多数进程OK的情况下进入临界区，但实现复杂。</p>
<h4 id="3-令牌环算法">3.令牌环算法</h4><p>(1)算法</p>
<ul>
<li>假设：总线式的网络中，进程没有固定的顺序，环中为每个进程分配了一个位置，每个进程都直到谁在它的下一个位置。</li>
<li>当环初始化时，进程0得到一个令牌token。该令牌绕着环运行，用点对点发送消息的方式把它从进程k传递到进程k+1(以环大小为模)。进程从它邻近的进程得到令牌后，检查自己是否要进入临界区。如果自己要进入临界区，那么它就进入临界区，做它要做的工作，然后离开临界区。在该进程退出临界区后，它沿着环继续传递令牌。不允许使用同一个令牌进入另一个临界区。</li>
<li>如果一个进程得到了邻近进程传来的令牌，但是它并不想进入临界区，那么它只是将令牌沿环往下传递。因而，当没有进程想进入临界区时，令牌就绕环高速传递。</li>
</ul>
<p>(2)优点</p>
<p>没有饥饿现象：任何时候都只有一个进程有令牌，并且令牌以固定的顺序循环传递。</p>
<p>(3)缺点</p>
<p>如果令牌丢失，必须重新生成令牌.</p>
<p>检测令牌丢失很困难，网络中令牌出现两次的时间间隔不确定，没有发现令牌可能是丢失，也可能是某个进程在占用。</p>
<p>如果有进程崩溃，该算法会有问题。(恢复方法： 要求每个进程维护进程环的配置信息， 每个进程收到令牌后发出确认信息，当它尝试把令牌传递给它的邻近进程时，如果没有收到确认，该进程就崩溃了，从组中删除该进程，继续传递令牌。)</p>
<h4 id="三种互斥算法的比较">三种互斥算法的比较</h4><p>（1）程进入临界区，需要发送的消息数目不同</p>
<p>集中式算法: 3条消息，请求，允许，释放，简单而有效.</p>
<p>分布式算法：2(n-1)条</p>
<p>令牌环算法: 1~(n-1)条</p>
<p>（2）进入临界区之前的消息延迟不同<br>集中式算法: 2条消息，请求，允许。</p>
<p>分布式算法：2(n-1)条</p>
<p>令牌环算法: 0~(n-1)条</p>
<p>（3）三种算法在这三种算法在进程崩溃的情况下都损失惨重。为了避免进程崩溃造成的系统瘫痪，必须引入专门的措施和额外的复杂性。</p>
<h3 id="资源">资源</h3><p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part1/" title="分布式系统总结part1" target="_blank" rel="external">分布式系统总结part1 中间件，进程迁移，移动通信失效，名称解析，移动实体定位</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part2/" title="分布式系统总结part2" target="_blank" rel="external">分布式系统总结part2 Lamport同步与向量时间戳，两大选举算法，三大互斥算法</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part3/" title="分布式系统总结part3" target="_blank" rel="external">分布式系统总结part3 复制和一致性(以数据和以客户为中心的一致性)，容错（拜占庭将军问题，两阶段与三阶段提交）</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part4/" title="分布式系统总结part4" target="_blank" rel="external">分布式系统总结part4 Petri网解决哲学家问题和生产者、消费者问题</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.cyanny.com/2013/11/24/distributed-system-review-part2/" data-id="cibosbb4h005qgprt4kbdyih7" class="article-share-link">Share</a>
      
        <a href="http://www.cyanny.com/2013/11/24/distributed-system-review-part2/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Learning/">Learning</a></li></ul>

    </footer>
  </div>
  
</article>


    
      <article id="post-distributed-system-review-part1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/24/distributed-system-review-part1/">分布式系统总结part1</a>
    </h1>
  

        <div class="article-meta">
          <div class="article-date">
  <i class="fa fa-calendar"></i>
  <a href="/2013/11/24/distributed-system-review-part1/">
    <time datetime="2013-11-24T03:12:15.000Z" itemprop="datePublished">2013-11-24</time>
  </a>
</div>
          
  <div class="article-category">
  	<i class="fa fa-folder"></i>
    <a class="article-category-link" href="/categories/Distributed-System/">Distributed System</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Distributed-System/Life/">Life</a>
  </div>

        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>激动哥给了一些点，总结如下吧，算是对分布式的一些理解，希望对朋友们有帮助。</p>
<h3 id="分布式系统系统基本概念">分布式系统系统基本概念</h3><p>分布式系统是若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。透明性, 故障透明性。</p>
<p>本质： 硬件上——机器是物理上独立的。软件上——对用户来说它们就像载和单个系统打交道。分布式系统位于用户的应用层和底层操作系统之间，有时也叫做中间件.</p>
<p>分布式系统的目标：资源链接和共享，透明性，开放性，可伸缩性。[more…]</p>
<h3 id="分布式系统作为中间件技术">分布式系统作为中间件技术</h3><ol>
<li><p>中间件在分布式系统中的位置</p>
<p>中间件：在应用系统和网络系统之间的附加的软件层，隐藏网络操作系统中低层平台集合的异构性，提供一组完整程度不同的服务集，提高分布的透明性。</p>
<p>中间件的最高目标是透明性。同时也具有开放性、可扩展性和易用性</p>
</li>
<li><p>中间件模型</p>
</li>
</ol>
<ul>
<li>基于分布式文件系统：任何东西都是作为文件来处理，只对传统文件支持分布的透明性，比网络操作系统前进了一小步，仍然要求进程显式启动分布式机器，有一定的扩展。</li>
<li>基于RPC：允许进程调用位于远程机器上的过程实现来隐藏网络通信。调用参数透明的传递到远程机器上，看起来就像在调用本地的进程一样，不知道网络通信的发生。</li>
<li>基于分布式对象: 调用分布在远程机器上的对象的接口，通过消息传递调用</li>
</ul>
<p>3.中间件通信技术</p>
<p>(1) RPC</p>
<p>使用客户端存根和服务器端存根，实现访问的透明性，按值传递，对引用传递的支持比较弱， 基于响应的暂时同步通信。</p>
<p>(2) RMI——远程对象调用</p>
<p>不使用用客户端存根和服务器端存根，使用针对对象的存根。本质上是RPC，但针对远程对象。</p>
<p>(3) MPI:面向消息的通信</p>
<p>RPC和RMI的不足：要求远程机器正在执行; 并且对同步要求高，客户在发出请求后阻塞</p>
<p>通信类型：持久通信，暂时通信；异步通信，同步通信； 两两正交共四种。</p>
<p>•持久异步通信：如邮件系统，消息队列</p>
<p>•持久同步通信</p>
<p>•暂时异步通信：如异步RPC，UDP</p>
<p>•暂时同步通信：基于接收的暂时同步通信：最弱的基于消息接收机制; 基于交付的暂时同步通信;基于响应的暂时同步通信： RMI， RPC。</p>
<p>MPI比套接字提供更多的抽象的消息传递原语，提供持久异步通信，用在RPC和RMI不适用的场合，它们主要用来协助将高度分散的数据库集成进大规模信息系统中。其他的应用还包括电子邮件和工作流。</p>
<p>(4)面向流的通信：</p>
<p>流是一种完全不同的通信方式，它的主要问题是两个连续的消息是否有时间上的联系。如音频流和视频流，同步很关键。</p>
<p>在连续数据流中，每个消息都规定了端到端的最大延迟时间。另外，发送的消息还要受端到端最小延迟时间的约束。</p>
<p>三种传输模式</p>
<p>异步传输模式：数据项是逐个传输的，但是对某一项在何时进行传输并没有进一步的限制。</p>
<p>同步传输模式：数据流中每一个单元都定义了一个端到端最大延迟时间。</p>
<p>等待传输模式：模式中数据单元必须按时传输，也就是数据传输的端到端延迟时间必须同时受到上限和下限的约束，实时系统。</p>
<h3 id="进程迁移">进程迁移</h3><ol>
<li><p>弱迁移 vs 弱迁移</p>
<p>弱迁移：即代码的可移植性，只传输代码段以及某些初始化数据，传输过来的程序总是以初始状态重新开始执行，弱可迁移性只要求在目标机器上能执行该代码段，例如Java Applet小程序，这种方法的好处在于简单性。</p>
<p>强迁移：迁移执行中的进程，先停止运行中的进程，捕捉运行现场，迁移到另一台机器上，从中断处继续运行，强迁移比弱迁移实现难度大，例如D’Agent是支持强可移动性的一个例子(Dartmouth College)</p>
</li>
<li><p>发送者启动迁移 vs 接收者启动迁移</p>
<p>发送者启动迁移，代码或正在执行的进程在哪台机器上，就由该机器来启动迁移，例如向Web服务器发送搜索程序运行查询。这种迁移容易实现.</p>
<p>接收者启动迁移，代码迁移的主动权在目标机器手中，例如Java Applet</p>
<p>区别：接收者下载代码到客户端，性能好，安全性好，客户端只有少数的资源需要保护，如内存和网络连接等；</p>
<p>发送者启动迁移，上传代码到服务器端，需要认证用户，需要对服务器资源提供强保护。</p>
</li>
<li><p>在目标进程内执行迁移代码 vs 在派生进程内执行迁移代码</p>
</li>
</ol>
<p>三种方法相互正交，形成了8中进程迁移方法，如图：</p>
<p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System20.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/Distributed-System20-580x300.png" alt="Distributed System20"></a></p>
<h3 id="移动Agent的基本概念">移动Agent的基本概念</h3><ol>
<li><p>定义：是一种分布式的应用，移动Agent是一个运行于开放、动态网络环境中的，封装良好的计算实体，可自主地在异构的网络上寻找合适的计算资源，然后移动到资源所在机器上使用这些资源，它代表用户自主地在网络上移动，完成指定的任务。移动Agent由数据、操作、行为规则 封装而成。</p>
</li>
<li><p>基本特点：</p>
</li>
</ol>
<ul>
<li>自主移动性：不拘泥于初始执行结点，可再网络各主机间自主移动。移动Agent可以将自身的状态和代码从一个环境迁移到另一个环境，并恢复执行。</li>
<li>协作性：移动Agent可以和其他Agent进行自主通信，协作完成任务。</li>
<li>安全性</li>
<li>移动功能而不移动数据，减少网络负担和延迟</li>
</ul>
<h3 id="Mogent解决移动通信失效">Mogent解决移动通信失效</h3><p>1.移动通信失效定义</p>
<p>移动Agent最大的特性是移动性，其通信机制要求位置透明性，可靠性，高效性，异步性，自适应性。但在Agent自主移动过程中，常会导致消息发送到某一网络节点但接收者已经离开无法收到消息的情况，这种因为目标Agent的物理位置变化造成通信不正常的现象称为移动Agent通信失效。通信失效与网络和节点故障无关，完全是由Agent的移动性造成的，这是移动Agent协作的致命缺陷。</p>
<p>2. Mogent系统架构</p>
<p>一个完整的移动Agent通信协议至少包括Agent寻址和消息传送两大部分。Mogent系统采用结构化旅行计划模型。</p>
<p>Mogent的架构中有两个重要实体：</p>
<ul>
<li>Mogent： 即移动Agent，可以协同工作。</li>
<li>Host：一个物理节点的抽象，由IP地址或域名来标识，每一个Host安装MogentServer，维护管理本地的Mogent，主要由迁移子系统、通信子系统、安全子系统和开发监控子系统构成。</li>
</ul>
<p>3.Mogent系统的寻址</p>
<p>Mogent-Server中有两个部件Home和Communicator完成Agent的透明寻址。</p>
<p>Home：记录Host上“出生的”Agent的动态信息，Agent每次迁移到另一台Host必须向出生地登记当前的地址和物理名，基于起始位置的定位。</p>
<p>Communicator：记录当前Host上所有agent的信息，Agent迁移时要向Communicator register 和 unregister, 负责agent之间通信的目标寻址、信件转发和通信失效排除等通信细节。</p>
<p>4.通信失效的解决：消息传送</p>
<p><strong>通信失效问题本质上是通信和移动所共享的“位置”信息未同步造成的。</strong><br>Mogent系统中引入了“状态”的概念，每个Agent的状态分为迁移态和静止态。</p>
<p>同时引入两个信号量进行集中式同步控制策略，通过Home-Communicator集中管理对目标Mogent的地址信息的互斥访问，从根本上避免通信失效的发生，保证通信的可靠性。</p>
<ul>
<li>迁移状态：由Home构件记录Agent的状态，当Mogent在一个Host上时状态为静止态，当按旅行计划准备迁移时Mogent要通知Home更新状态为迁移态。</li>
<li>在途信件数：保存在Host上，记录当前时刻以该Mogent为通信对象的在途信件数，发出信件，在途信件数增加，信件到达，在途信件数减一</li>
</ul>
<p>消息发送机制：Mogent通过控制“在途信件数”和“迁移状态”这两个信号量，确保消息发送者仅向处于静止状态的Agent发送消息</p>
<p>Mogent迁移机制：Agent只有在没有消息发送给他的情况下才能移动。</p>
<p>5.Mogent局限性</p>
<ul>
<li>频繁迁移，Home的地址注册开销大，会拥挤</li>
<li>Agent迁移受到信号量的限制,影响Agent的自主性和移动性</li>
</ul>
<h3 id="两种名称解析方法:递归和迭代">两种名称解析方法:递归和迭代</h3><p>分布式系统中名称用来标识一个实体，有三种类型——名称、标识符、地址，名称解析就是查询名称的过程。</p>
<p>1.迭代名称解析</p>
<p>客户端把需要解析的名称路径发给根服务器root，根服务器解析出下一个服务器server1的地址返回给客户端，客户端再查询server1，server1再解析出server2的地址…</p>
<p>如此迭代直到能解析出所需实体的地址。例如：考虑绝对路径名：root:&lt;nl, vu, cs, ftp, pub, globe, index.txt&gt;的解析，第四章PPT上有详细的说明</p>
<p>总之迭代名称解析是客户端发起迭代查询。</p>
<p>2.递归名称解析</p>
<p>客户端把需要解析的名称路径发给根服务器root，根服务器解析出server1的地址后，不把结果返回给客户端，直接把名称传给server1，由server1解析后，再传给server2…不断递归，最后将解析出的实体地址返回给根服务器，根服务器再将实体地址返回给客户端。</p>
<p>3.两种解析的比较<br>递归名称解析的缺陷：要求每台服务器具有较高的性能，根服务器要完成完整的名称解析，开销较大，一般在名称空间的全局层中，采用迭代名称解析。</p>
<p>优点：与迭代名称解析相比，递归解析可以有效的使用缓存提高性能；减少了通信开销，通信开销取决于客户主机和服务器之间的信息交换。</p>
<p>而在DNS解析中：从客户机到本地DNS的查询是递归查询，从本地DNS到到其他DNS服务器之间的查询是迭代查询</p>
<h3 id="移动实体的定位">移动实体的定位</h3><p>移动实体的定位方法：使用与位置无关的标识符有效地实现定位。</p>
<p><strong>1.广播和多播</strong></p>
<p><strong>原理：</strong>包含该实体所用标识符的消息会广播到每台机器上，并且请求每台机器查看它是否拥有该实体。只有能够为实体提供访问点的机器才会发送回复消息，回复消息中包含访问点的地址。类比ARP</p>
<p><strong>缺点：</strong>扩展性不好，随着网络的膨胀，广播变得更加低效。</p>
<p>可以采用多播向特定的一组主机发送标识符，使用多播查找最近的复制实体，但实践证明，选择最近的复制实体没有那么容易。</p>
<p><strong>2.转发指针</strong></p>
<p><strong>原理：</strong>每当一个实体转移到另一个位置时，他就会留下一个指针，说明它下一步所在的位置。 例如：当实体从A移动到B时，它将在A中留下一个指针，这个指针指向它在B中的新位置。</p>
<p>定位实体需要遍历转发指针形成的路线。为了避免形成太长的指针链，定期缩短指针链很重要。</p>
<p><strong>优点：</strong>简便，一旦找到一个实体，就可以顺着转发指针链查找到实体当前的地址。</p>
<p><strong>缺点：</strong>链可能特别长，定位实体的开销较大。链很脆弱，容易断开，只要一个转发指针丢失，就无法定位实体。一个解决办法是让指针链相对短一些，确保转发指针链的健壮性。<br>链中所有中间位置就必须维护它们的那一部分指针链。</p>
<p><strong>3.基于起始位置的方法</strong></p>
<p><strong>原理：</strong>每当实体转移到一个地方时，他会通知起始位置，告诉起始位置自己当前的位置，在定位实体时，首先询问起始位置，以便了解实体的当前位置。起始位置就是创建实体的位置。</p>
<p><strong>优点：</strong>大型网络中进行实体定位,如Mogent</p>
<p><strong>缺点：</strong>为了与移动实体通信，需要先和起始位置通信，而起始位置和实体本身的位置处于完全不同的位置，增加了通信延迟。    使用起始位置，必须保证起始位置始终存在，否则将无法定位实体。起始位置如果转移到另一个网络，将会无法定位实体。一种解决的办法是：注册起始位置，客户先查找起始位置所在的位置，起始位置相对稳定，可以缓存它。</p>
<p><strong>4.分层方法——创建一颗搜索树</strong></p>
<p><strong>原理：</strong> 网络划分成不重叠的分层域。只有一个顶级域，它覆盖了整个网络，每个域又可以划分为更多的子域。最低层的域叫做叶域，与网络中的局域网向对应。</p>
<p>每个层次的每个域都有关联的目录节点，目录节点会持续跟踪实体，形成目录节点树。</p>
<p>顶级域拥有每个实体的位置记录(指针)，其中每条位置记录都存储一个指向更低层子域目录节点的指针 </p>
<p><strong>优点：</strong>查询操作是在局部进行，最差情况下，搜索会从叶域一直查到根域，再从根域到达包括该实体地址的子域。更新，插入和删除操作是局部进行：从叶节点到根节点。</p>
<p><strong>缺点：</strong>第一， 定位实体的开销较大，从叶节点到根节点，再到叶节点。一种解决方法是采用指针缓存。第二，扩展性问题： 根节点需要存储所有实体的位置记录, 并为每个实体处理请求， 太多的查询和更新请求会成为瓶颈。解决办法是把根节点和其他高层目录节点划分成多个子节点，每个子节点处理实体的定位请求。<br>这些子节点最好均匀的扩散到网络中</p>
<h3 id="资源">资源</h3><p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part1/" title="分布式系统总结part1" target="_blank" rel="external">分布式系统总结part1 中间件，进程迁移，移动通信失效，名称解析，移动实体定位</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part2/" title="分布式系统总结part2" target="_blank" rel="external">分布式系统总结part2 Lamport同步与向量时间戳，两大选举算法，三大互斥算法</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part3/" title="分布式系统总结part3" target="_blank" rel="external">分布式系统总结part3 复制和一致性(以数据和以客户为中心的一致性)，容错（拜占庭将军问题，两阶段与三阶段提交）</a></p>
<p><a href="http://cyanny/myblog/2013/11/24/distributed-system-review-part4/" title="分布式系统总结part4" target="_blank" rel="external">分布式系统总结part4 Petri网解决哲学家问题和生产者、消费者问题</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.cyanny.com/2013/11/24/distributed-system-review-part1/" data-id="cibosbb4k005ugprt117akpfr" class="article-share-link">Share</a>
      
        <a href="http://www.cyanny.com/2013/11/24/distributed-system-review-part1/#disqus_thread" class="article-comment-link">Comments</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Learning/">Learning</a></li></ul>

    </footer>
  </div>
  
</article>


    
      <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
      </nav>
    </section>
      
        <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">recents</h3>
    <div class="widget">
      <ul id="recent-post" class="no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
              <p class="item-title"><a href="/2015/05/04/bitsort-ant-qsort/" class="title">位排序和快排</a></p>
              <p class="item-date"><time datetime="2015-05-04T13:57:53.000Z" itemprop="datePublished">2015-05-04</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-inner">
              <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
              <p class="item-title"><a href="/2015/04/03/find-median-for-two-sorted-array/" class="title">查找两个排序数组的中位数</a></p>
              <p class="item-date"><time datetime="2015-04-03T14:07:01.000Z" itemprop="datePublished">2015-04-03</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-inner">
              <p class="item-category"><a class="article-category-link" href="/categories/Hadoop/">Hadoop</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Hadoop/Hive/">Hive</a></p>
              <p class="item-title"><a href="/2014/08/16/hive-architecture/" class="title">Hive架构笔记</a></p>
              <p class="item-date"><time datetime="2014-08-16T15:32:27.000Z" itemprop="datePublished">2014-08-16</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-inner">
              <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
              <p class="item-title"><a href="/2014/04/12/dijkstra-algorithm-in-java/" class="title">Dijkstra Algorithm</a></p>
              <p class="item-date"><time datetime="2014-04-12T03:55:04.000Z" itemprop="datePublished">2014-04-12</time></p>
            </div>
          </li>
        
          <li>
            
            <div class="item-inner">
              <p class="item-category"><a class="article-category-link" href="/categories/Hadoop/">Hadoop</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/Hadoop/HBase/">HBase</a></p>
              <p class="item-title"><a href="/2014/03/20/hbase-mapreduce-e6-8e-92-e5-ba-8f-secondary-sort/" class="title">HBase MapReduce排序Secondary Sort</a></p>
              <p class="item-date"><time datetime="2014-03-20T10:51:08.000Z" itemprop="datePublished">2014-03-20</time></p>
            </div>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Agile/">Agile</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Agile/Life/">Life</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/">Distributed System</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Distributed-System/Life/">Life</a><span class="category-list-count">4</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/">Hadoop</a><span class="category-list-count">16</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/HBase/">HBase</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hadoop/Hive/">Hive</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Life/">Life</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Network/">Network</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Nodejs/">Nodejs</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/System-Analysis-and-Design/">System Analysis and Design</a><span class="category-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">tag cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Agile/" style="font-size: 10px;">Agile</a> <a href="/tags/Big-Data/" style="font-size: 12.86px;">Big Data</a> <a href="/tags/Design/" style="font-size: 14.29px;">Design</a> <a href="/tags/HBase/" style="font-size: 15.71px;">HBase</a> <a href="/tags/Hadoop/" style="font-size: 18.57px;">Hadoop</a> <a href="/tags/Hive/" style="font-size: 10px;">Hive</a> <a href="/tags/JavaScript/" style="font-size: 10px;">JavaScript</a> <a href="/tags/Learn/" style="font-size: 10px;">Learn</a> <a href="/tags/Learning/" style="font-size: 20px;">Learning</a> <a href="/tags/Linux/" style="font-size: 11.43px;">Linux</a> <a href="/tags/MapReduce/" style="font-size: 10px;">MapReduce</a> <a href="/tags/Methodology/" style="font-size: 10px;">Methodology</a> <a href="/tags/Network/" style="font-size: 10px;">Network</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Research/" style="font-size: 17.14px;">Research</a> <a href="/tags/Resource/" style="font-size: 10px;">Resource</a> <a href="/tags/Scrum/" style="font-size: 10px;">Scrum</a> <a href="/tags/SystemAnalysis/" style="font-size: 14.29px;">SystemAnalysis</a> <a href="/tags/VPS/" style="font-size: 11.43px;">VPS</a> <a href="/tags/algorithm/" style="font-size: 17.14px;">algorithm</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/math/" style="font-size: 10px;">math</a> <a href="/tags/nodejs/" style="font-size: 10px;">nodejs</a> <a href="/tags/sort/" style="font-size: 11.43px;">sort</a>
    </div>
  </div>

  
  <div id="toTop" class="fa fa-chevron-up"></div>
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Cyanny Liang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    

<script>
  var disqus_shortname = 'lgrcyanny';
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>


<script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>