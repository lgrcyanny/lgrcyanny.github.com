<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 4 | CyannyLive</title>

  
  <meta name="author" content="Cyanny Liang">
  

  
  <meta name="description" content="Do not go gentle into that good night">
  

  

  <meta id="viewport" name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">

  

  <meta property="og:site_name" content="CyannyLive"/>

  
  <meta property="og:image" content="/favicon.ico"/>
  

  <link href="/favicon.ico" rel="icon">
  <link rel="alternate" href="/atom.xml" title="CyannyLive" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
</head>


<body>
<div class="blog">
  <div class="content">

    <header>
  <div class="site-branding">
    <h1 class="site-title">
      <a href="/">CyannyLive</a>
    </h1>
    <p class="site-description"></p>
  </div>
  <nav class="site-navigation">
    <ul>
      
        <li><a href="/">Home</a></li>
      
        <li><a href="/archives">Archives</a></li>
      
        <li><a href="/about/">About</a></li>
      
    </ul>
  </nav>
</header>

    <main class="site-main posts-loop">
    
  <article>

  
    
    <h3 class="article-title"><a href="/2013/12/05/hadoop-mapreduce-2-yarn/"><span>Hadoop MapReduce 2 (YARN)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/12/05/hadoop-mapreduce-2-yarn/" rel="bookmark">
        <time class="entry-date published" datetime="2013-12-05T08:57:01.000Z">
          2013-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>For large clusters with more than 4000 nodes, the classic MapReduce framework hit the scalability problems.<br><strong>Therefore, a group in Yahoo began to design the next generation MapReduce in 2010, and in 2013 Hadoop 2.x releases MapReduce 2, Yet Another Resource Negotiator (YARN) to remedy the sociability shortcoming.</strong><br>The fundamental idea of YARN is to split up the two major functionalities of the JobTracker: resource management (job scheduling) and job monitoring into separate daemons. YARN has a global Resource Manager (RM) and per-application Application Master(AM).[more…]</p>
<h3 id="YARN-High-level-Overview"><a href="#YARN-High-level-Overview" class="headerlink" title="YARN High-level Overview"></a>YARN High-level Overview</h3><p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd7.1.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd7.1.png" alt="hd7.1">Figure1 YARN High-level Overview</a><br>As shown in Figure1, the YARN involves more entities than classic MapReduce 1 :</p>
<ul>
<li>Client, the same as classic MapReduce which submits the MapReduce job.</li>
<li>Resource Manager, which has the ultimate authority that arbitrates resources among all the applications in the cluster, it coordinates the allocation of compute resources on the cluster.</li>
<li>Node Manager, which is in charge of resource containers, monitoring resource usage (cpu, memory, disk , network) on the node , and reporting to the Resource Manager.</li>
<li>Application Master, which is in charge of the life cycle an application, like a MapReduce Job. It will negotiates with the Resource Manager of cluster resources—in YARN called containers. The Application Master and the MapReduce task in the containers are scheduled by the Resource Manager. And both of them are managed by the Node Manager. Application Mater is also responsible for keeping track of task progress and status. </li>
<li>HDFS, the same as classic MapReduce, for files sharing between different entities.</li>
</ul>
<p>Resource Manager consists of two components: Scheduler and ApplicationsManager.</p>
<p>Scheduler is in charge of allocating resources. The resource Container incorporates elements such as memory, cup, disk, network etc. Scheduler just has the resource allocation function, has no responsible for job status monitoring. And the scheduler is pluggable, can be replaced by other scheduler plugin-in.</p>
<p>The ApplicationsManager is responsible for accepting job-submissions, negotiating the first container for executing the application specific Application Master, and it provides restart service when the container fails.<br>The MapReduce job is just one type of application in YARN. Different application can run on the same cluster with YARN framework. That’s the beauty of YARN.</p>
<h3 id="YARN-MapReduce"><a href="#YARN-MapReduce" class="headerlink" title="YARN MapReduce"></a>YARN MapReduce</h3><p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd7.2.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd7.2.png" alt="hd7.2">Figure2 MapReduce with YARN</a><br>As shown in Figure2, it is the MapReduce process with YARN, there are 11 steps, and we will explain it in 6 steps the same as the MapReduce 1 framework. They are Job Submission, Job Initialization, Task Assignment, Task Execution, Progress and Status Updates, and Job Completion.</p>
<h4 id="Job-Submission"><a href="#Job-Submission" class="headerlink" title="Job Submission"></a>Job Submission</h4><p>Clients can submit jobs with the same API as MapReduce 1 in YARN. YARN implements its ClientProtocol, the submission process is similar to MapReduce 1.</p>
<ul>
<li>The client calls the submit() method, which will initiate the JobSubmmitter object and call submitJobInternel().</li>
<li>Resource Manager will allocate a new application ID and response it to client.</li>
<li>The job client checks the output specification of the job</li>
<li>The job client computes the input splits</li>
<li>The job client copies resources, including the splits data, configuration information, the job JAR into HDFS</li>
<li>Finally, the job client notify Resource Manager it is ready by calling submitApplication() on the Resource Manager.</li>
</ul>
<h4 id="Job-Initialization"><a href="#Job-Initialization" class="headerlink" title="Job Initialization"></a>Job Initialization</h4><p> When the Resource Manager(RM) receives the call submitApplication(), RM will hands off the job to its scheduler. The job initialization is as follows:</p>
<ul>
<li>The scheduler allocates a resource container for the job, </li>
<li>The RM launches the Application Master under the Node Manager’s management. </li>
<li>Application Master initialize the job. Application Master is a Java class named MRAppMaster, which initializes the job by creating a number of bookkeeping objects to keep track of the job progress. It will receive the progress and the completion reports from the tasks. </li>
<li>Application Master retrieves the input splits from HDFS, and creates a map task object for each split. It will create a number of reduce task objects determined by the mapreduce.job.reduces configuration property.</li>
<li>Application Master then decides how to run the job. </li>
</ul>
<p>For small job, called uber job, which is the one has less than 10 mappers and only one reducer, or the input split size is smaller than a HDFS block, the Application Manager will run the job on its own JVM sequentially. This policy is different from MapReduce 1 which will ignore the small jobs on a single TaskTracker.</p>
<p>For large job, the Application Master will launches a new node with new NodeManager and new container, in which run the task. This can run job in parallel and gain more performance. </p>
<p>Application Master calls the job setup method to create the job’s output directory. That’s different from MapReduce 1, where the setup task is called by each task’s TaskTracker.</p>
<h4 id="Task-Assignment"><a href="#Task-Assignment" class="headerlink" title="Task Assignment"></a>Task Assignment</h4><p>When the job is very large so that it can’t be run on the same node as the Application Master. The Application Master will make request to the Resource Manager to negotiate more resource container which is in piggybacked on heartbeat calls. The task assignment is as follows:</p>
<ul>
<li>The Application Master make request to the Resource Manager in heartbeat call. The request includes the data locality information, like hosts and corresponding racks that the input splits resides on. </li>
<li>The Recourse Manager hand over the request to the Scheduler. The Scheduler makes decisions based on these information. It attempts to place the task as close the data as possible. The data-local nodes is great, if this is not possible , the rack-local the preferred to nolocal node.</li>
<li>The request also specific the memory requirements, which is between the minimum allocation (1GB by default) and the maximum allocation (10GB). The Scheduler will schedule a container with multiples of 1GB memory to the task, based on the mapreduce.map.memory.mb and mapreduce.reduce.memory.mb property set by the task.</li>
</ul>
<p>This way is more flexible than MapReduce 1. In MapReduce 1, the TaskTrackers have a fixed number of slots and each task runs in a slot. Each slot has fixed memory allowance which results in two problems. For small task, it will waste of memory, and for large task which need more memeory, it will lack of memory.<br>In YARN, the memory allocation is more fine-grained, which is also the beauty of YARE resides in.</p>
<h4 id="Task-Execution"><a href="#Task-Execution" class="headerlink" title="Task Execution"></a>Task Execution</h4><p>After the task has been assigned the container by the Resource Manger’s scheduler, the Application Master will contact the NodeManger which will launch the task JVM.<br>The task execution is as follows:</p>
<ul>
<li>The Java Application whose class name is YarnChild localizes the resources that the task needs. YarnChild retrieves job resources including the job jar, configuration file, and any needed files from the HDFS and the distributed cache on the local disk.</li>
<li>YarnChild run the map or the reduce task<br>Each YarnChild runs on a dedicated JVM, which isolates user code from the long running system daemons like NodeManager and the Application Master. Different from MapReduce 1, <strong>YARN doesn’t support JVM reuse</strong>, hence each task must run on new JVM.<br>The streaming and the pipeline processs and communication in the same as MapReduce 1.</li>
</ul>
<h4 id="Progress-and-Status-Updates"><a href="#Progress-and-Status-Updates" class="headerlink" title="Progress and Status Updates"></a>Progress and Status Updates</h4><p>When the job is running under YARN, the mapper or reducer will report its status and progress to its Application Master every 3 seconds over the umbilical interface. The Application Master will aggregate these status reports into a view of the task status and progress. While in MapReduce 1, the TaskTracker reports status to JobTracker which is responsible for aggregating status into a global view.<br>Moreover, the Node Manger will send heartbeats to the Resource Manager every few seconds. The Node Manager will monitoring the Application Master and the recourse container usage like cpu, memeory and network, and make reports to the Resource Manager. When the Node Manager fails and stops heartbeat the Resource Manager, the Resource Manager will remove the node from its available resource nodes pool.<br>The client pulls the status by calling getStatus() every 1 second to receive the progress updates, which are printed on the user console. User can also check the status from the web UI. The Resource Manager web UI will display all the running applications with links to the web UI where displays task status and progress in detail.<br><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd7.3.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd7.3.png" alt="hd7.3">Figure 3  YARN Progress and Status Updates</a></p>
<h4 id="Job-Completion"><a href="#Job-Completion" class="headerlink" title="Job Completion"></a>Job Completion</h4><p>Every 5 second the client will check the job completion over the HTTP ClientProtocol by calling waitForCompletion(). When the job is done, the Application Master and the task containers clean up their working state and the outputCommitter’s job cleanup method is called. And the job information is archived as history for later interrogation by user.</p>
<p>Resources:<br><a href="http://cyanny/myblog/2013/12/05/hadoop-overview/" title="Hadoop Overview" target="_blank" rel="external">Part 0 Hadoop Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-review/" title="Hadoop HDFS Review" target="_blank" rel="external">Part 1 Hadoop HDFS Review</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-federation/" title="Hadoop HDFS Federation" target="_blank" rel="external">Part 2 Hadoop HDFS Federation</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-high-availability/" title="Hadoop HDFS High Availability(HA)" target="_blank" rel="external">Part 3 Hadoop HDFS High Availability(HA)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-overview/" title="Hadoop MapReduce Overview" target="_blank" rel="external">Part 4 Hadoop MapReduce Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-1-framework/" title="Hadoop MapReduce 1 Framework" target="_blank" rel="external">Part 5 Hadoop MapReduce 1 Framework</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-2-yarn/" title="Hadoop MapReduce 2 (YARN)" target="_blank" rel="external">Part 6 Hadoop MapReduce 2 (YARN)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-isnt-silver-bullet/" title="Hadoop isn’t Silver Bullet" target="_blank" rel="external">Part 7 Hadoop isn’t Silver Bullet</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/hadoop/">Hadoop</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/learning/">Learning</a><a href="/tags/hadoop/">Hadoop</a><a href="/tags/research/">Research</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/12/05/hadoop-mapreduce-2-yarn/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/12/05/hadoop-mapreduce-1-framework/"><span>Hadoop MapReduce 1 Framework</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/12/05/hadoop-mapreduce-1-framework/" rel="bookmark">
        <time class="entry-date published" datetime="2013-12-05T08:11:12.000Z">
          2013-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>For MapReduce programming, a developer can run a MapReduce job by simply calling submit() or waitForCompletion() on a job object. This method abstracts the job processing details away from developer. But there is a great of job processing behind the scene that we will consider in this section.<br>Hadoop 2.x has released new MapReduce framework implementation called YARN or MapReduce 2, for traditional MapReduce is the classic framework which is also called MapReduce 1. YARN is compatible with MapReduce 1. [more…]</p>
<h3 id="MapReduce-1-high-level-overview"><a href="#MapReduce-1-high-level-overview" class="headerlink" title="MapReduce 1 high level overview"></a>MapReduce 1 high level overview</h3><p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd6.2.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd6.2.png" alt="hd6.2">Figure1 Classic MapReduce Framework</a><br>As shown in Figure 1, there are four independent entities in the framework:</p>
<ul>
<li>Client, which submits the MapReduce Job</li>
<li>JobTracker, which coordinates and controls the job run. It is a Java class called JobTracker.</li>
<li>TaskerTrackers, which run the task that is split job, control the specific map or reduce task, and make reports to JobTracker. They are Java class as well.</li>
<li>HDFS, which provides distributed data storage and is used to share job files between other entities.</li>
</ul>
<p>As the Figure 1 show, a MapReduce processing including 10 steps, and in short, that is:</p>
<ul>
<li>The clients submit MapReduce jobs to the JobTracker. </li>
<li>The JobTracker assigns Map and Reduce tasks to other nodes in the cluser</li>
<li>These nodes each run a software daemon TaskTracker on separate JVM.</li>
<li>Each TaskTracker actually initiates the Map or Reduce tasks and reports progress back to the JobTracker</li>
</ul>
<h3 id="Job-Submission"><a href="#Job-Submission" class="headerlink" title="Job Submission"></a>Job Submission</h3><p>When the client call submit() on job object. An internal JobSubmmitter Java Object is initiated and submitJobInternal() is called. If the clients calls the waiForCompletion(), the job progresss will begin and it will response to the client with process results to clients until the job completion.<br>JobSubmmiter do the following work:</p>
<ul>
<li>Ask the JobTracker for a new job ID.</li>
<li>Checks the output specification of the job.</li>
<li>Computes the input splits for the job.</li>
<li>Copy the resources needed to run the job. Resources include the job jar file, the configuration file and the computed input splits. These resources will be copied to HDFS in a directory named after the job id. The job jar will be copied more than 3 times across the cluster so that TaskTrackers can access it quickly.</li>
<li>Tell the JobTracker that the job is ready for execution by calling submitJob() on JobTracker.</li>
</ul>
<h3 id="Job-Initialization"><a href="#Job-Initialization" class="headerlink" title="Job Initialization"></a>Job Initialization</h3><p>When the JobTracker receives the call submitJob(), it will put the call into an internal queue from where the job scheduler will pick it up and initialize it. The initialization is done as follow:</p>
<ul>
<li>An job object is created to represent the job being run. It encapsulates its tasks and bookkeeping information so as to keep track the task progress and status.</li>
<li>Retrieves the input splits from HDFS and create the list of tasks, each of which has task ID. JobTracker creates one map task for each split, and the number of reduce tasks according to configuration.</li>
<li>JobTracker will create the setup task and cleanup task. Setup task is to create the final output directory for the job and the temporary working space for the task output. Cleanup task is to delete the temporary working space for the task ouput.</li>
<li>JobTracker will assign tasks to free TaskTrackers</li>
</ul>
<h3 id="Task-Assignment"><a href="#Task-Assignment" class="headerlink" title="Task Assignment"></a>Task Assignment</h3><p>TaskTrackers send heartbeat periodically to JobTracker Node to tell it if it is alive or ready to get a new task. The JobTracker will allocate a new task to the ready TaskTracker. Task assignment is as follows:</p>
<ul>
<li>The JobTracker will choose a job to select the task from according to scheduling algorithm, a simple way is chosen on a priority list of job. After chose the job, the JobTracker will choose a task from the job.</li>
<li>TaskTrackers has a fixed number of slots for map tasks and for reduces tasks which are set independently, the scheduler will fits the empty map task slots before reduce task slots.</li>
<li>To choose a reduce task, the JobTracker simply takes next in its list of yet-to-be-run reduce task, because there is no data locality consideration. But map task chosen depends on the data locality and TaskTracker’s network location.</li>
</ul>
<h3 id="Task-Execution"><a href="#Task-Execution" class="headerlink" title="Task Execution"></a>Task Execution</h3><p>When the TaskTracker has been assigned a task. The task execution will be run as follows:</p>
<ul>
<li>Copy jar file from HDFS, copy needed files from the distributed cache on the local disk.</li>
<li>Creates a local working directory for the task and ‘un-jars’ the jar file contents to the direcoty</li>
<li>Creates a TaskRunner to run the task. The TaskRunner will lauch a new JVM to run each task.. TaskRunner fails by bugs will not affect TaskTracker. And multiple tasks on the node can reuse the JVM created by TaskRunner.</li>
<li>Each task on the same JVM created by TaskRunner will run setup task and cleanup task.</li>
<li>The child process created by TaskRunner will informs the parent process of the task’s progress every few seconds until the task is complete.</li>
</ul>
<h3 id="Progress-and-Status-Updates"><a href="#Progress-and-Status-Updates" class="headerlink" title="Progress and Status Updates"></a>Progress and Status Updates</h3><p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd6.3.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd6.3.png" alt="hd6.3">Figure 2 Classic MapReduce Framework Progress and Status Updates</a><br>After clients submit a job. The MapReduce job is a long time batching job. Hence the job progress report is important. What consists of the Hadoop task progress is as follows:</p>
<ul>
<li>Reading an input record in a mapper or reducer</li>
<li>Writing an output record in a mapper or a reducer</li>
<li>Setting the status description on a reporter, using the Reporter’s setStatus() method</li>
<li>Incrementing a counter</li>
<li>Calling Reporter’s progress()</li>
</ul>
<p><strong>As shown in Figure 2, when a task is running, the TaskTracker will notify the JobTracker its task progress by heartbeat every 5 seconds.</strong></p>
<p>And mapper and reducer on the child JVM will report to TaskTracker with it’s progress status every few seconds. The mapper or reducers will set a flag to indicate the status change that should be sent to the TaskTracker. The flag is checked in a separated thread every 3 seconds. If the flag sets, it will notify the TaskTracker of current task status.<br>The JobTracker combines all of the updates to produce a global view, and the Client can use getStatus() to get the job progress status.</p>
<h3 id="Job-Completion"><a href="#Job-Completion" class="headerlink" title="Job Completion"></a>Job Completion</h3><p>When the JobTracker receives a report that the last task for a job is complete, it will change its status to successful. Then the JobTracker will send a HTTP notification to the client which calls the waitForCompletion(). The job statistics and the counter information will be printed to the client console. Finally the JobTracker and the TaskTracker will do clean up action for the job.</p>
<p>Resources:<br><a href="http://cyanny/myblog/2013/12/05/hadoop-overview/" title="Hadoop Overview" target="_blank" rel="external">Part 0 Hadoop Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-review/" title="Hadoop HDFS Review" target="_blank" rel="external">Part 1 Hadoop HDFS Review</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-federation/" title="Hadoop HDFS Federation" target="_blank" rel="external">Part 2 Hadoop HDFS Federation</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-high-availability/" title="Hadoop HDFS High Availability(HA)" target="_blank" rel="external">Part 3 Hadoop HDFS High Availability(HA)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-overview/" title="Hadoop MapReduce Overview" target="_blank" rel="external">Part 4 Hadoop MapReduce Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-1-framework/" title="Hadoop MapReduce 1 Framework" target="_blank" rel="external">Part 5 Hadoop MapReduce 1 Framework</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-2-yarn/" title="Hadoop MapReduce 2 (YARN)" target="_blank" rel="external">Part 6 Hadoop MapReduce 2 (YARN)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-isnt-silver-bullet/" title="Hadoop isn’t Silver Bullet" target="_blank" rel="external">Part 7 Hadoop isn’t Silver Bullet</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/hadoop/">Hadoop</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/learning/">Learning</a><a href="/tags/hadoop/">Hadoop</a><a href="/tags/research/">Research</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/12/05/hadoop-mapreduce-1-framework/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/12/05/hadoop-mapreduce-overview/"><span>Hadoop MapReduce Overview</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/12/05/hadoop-mapreduce-overview/" rel="bookmark">
        <time class="entry-date published" datetime="2013-12-05T07:20:25.000Z">
          2013-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="MapReduce-Introduction"><a href="#MapReduce-Introduction" class="headerlink" title="MapReduce Introduction"></a>MapReduce Introduction</h3><p><strong>MapReduce is a parallel programming model and an associated implementation for processing and generating large data sets. The MapReduce model consists of two phrases: map and reduce.</strong> A map task is to process a key/value pair to generate a set of intermediate key/value pairs, and a reduce task is to merge all intermediate values associated with the same intermediated key.[more…]</p>
<p>Hadoop MapReduce is based on the MapReduce paper in 2006. This processing model is automatic parallelization and distribution. It provides a clean abstraction for programmers. MapReduce programs are usually written in java, and can be written in any scripting language like Ruby, Python, PHP using Hadoop Streaming, or in C++ using Hadoop Pipes. MapReduce abstracts all the ‘housekeeping’ away from the developer. Developer can concentrate simply on writing the Map and Reduce functions.</p>
<h3 id="MapReduce-Data-Flow"><a href="#MapReduce-Data-Flow" class="headerlink" title="MapReduce Data Flow"></a>MapReduce Data Flow</h3><p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd6.1.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd6.1.png" alt="hd6.1">Figure1 MapReduce Data Flow</a><br>As shown in Figure1, A MapReduce process consists of two phrases: map phrase and the reduce phrase. Let’s consider them in detail.</p>
<h4 id="The-Mapper"><a href="#The-Mapper" class="headerlink" title="The Mapper"></a>The Mapper</h4><p>A MapReduce job is a unit of work that the client wants to be run, including the input data, the MapReduce program and the configuration information. Hadoop runs the job by dividing it into tasks: map tasks and reduce tasks.<br>Hadoop divides the input data into fixed-size pieces call input splits or splits. Each map task runs on each split, which runs the user-defined map function. All of the map tasks runs in parallel. Usually, the split size is a HDFS block, 64MB or 128MB.<br><strong>If the file is less than 64MB or 128MB, it will not be split. And the file will occupy one block, results in a waste of storage.</strong><br>Map tasks usually runs on its local HDFS data, or the data near the node that runs the map task. Data Locality saves bandwidth and decreases dependencies.<br>The input value for map task is key/value pair. For example, in the WordCount example by Hadoop, the input value for map task: the key is the line offset whining the file, which we can ignore in our map function, the value is the line in the file.<br>In the map function, developers will process the value of each line, make sure the output is key/value pair, WorkCount again, the output for map function is like ‘<apple, 1="">, <pear, 1="">…’, key is the word, value is 1.<br><strong>Map tasks output is written to the local disk, not to HDFS, then the reduce task will use these intermediate output to do merge work.</strong> Because storing these intermediate data to HDFS with replication would be overkill. And if the map task fails before the reduce task consume the output, Hadoop will automatically start another map task on another node that will re-create the output. </pear,></apple,></p>
<h4 id="The-Reducer"><a href="#The-Reducer" class="headerlink" title="The Reducer"></a>The Reducer</h4><p>After map tasks done, the job tracker will start the reduce task. The reducer input is the intermediate mapper output.<br>Between the map task and the reduce task is the well known shuffle and sort. Hadoop will sort the intermediate map output by key. And each reduce task will run on map output with the same key. In WordCount example, the same key means the same word, like ‘<apple, 1=""> … <apple, 1="">’, will be assigned to a reduce task, the reduce function just sum up the value and calculate the word count for ‘apple’.<br>Reduce tasks don’t have the advantage of data locality, the sorted map output have to be transferred across the network to the node where the reduce task is running.<br>Then the reduce task will merge the data with the user-defined reduce function. The reduce output is normally stored in HDFS for reliability. For each reduce output block, the first replica is stored on the local node, while the other two replicas are stored on off-rack nodes.<br><strong>We can see that no reduce task can start until every map task has finished. Will the mapper become a bottleneck? Hadoop uses the ‘Speculative execution’ to mitigate against this:</strong></apple,></apple,></p>
<ul>
<li>If a Mapper appears to be running significantly more slowly than the others, a new instance of the Mapper will be started on another node, operating on the same data.</li>
<li>The results of the first Mapper to finish will be used</li>
<li>Hadoop will kill off the Mapper which is still running</li>
</ul>
<h4 id="The-Combiner"><a href="#The-Combiner" class="headerlink" title="The Combiner"></a>The Combiner</h4><p>Often, Mappers produce large amounts of intermediate data, which have to be transferred to Reducers that will result in a lot of network traffic.<br>To minimize the data transferred between Mapper and Reducer, Hadoop introduces the combiner function to be run on the map output, and combine the Mapper output and generate the Reducer Input.<br>Combiner is like a ‘Mini-Reducer’, runs locally on a the same node as Mapper. The output from the combiner is sent to the Reducers. Combiners decrease the amount of the network traffic required during the shuffle and sort phase. </p>
<p>Resources:<br><a href="http://cyanny/myblog/2013/12/05/hadoop-overview/" title="Hadoop Overview" target="_blank" rel="external">Part 0 Hadoop Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-review/" title="Hadoop HDFS Review" target="_blank" rel="external">Part 1 Hadoop HDFS Review</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-federation/" title="Hadoop HDFS Federation" target="_blank" rel="external">Part 2 Hadoop HDFS Federation</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-high-availability/" title="Hadoop HDFS High Availability(HA)" target="_blank" rel="external">Part 3 Hadoop HDFS High Availability(HA)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-overview/" title="Hadoop MapReduce Overview" target="_blank" rel="external">Part 4 Hadoop MapReduce Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-1-framework/" title="Hadoop MapReduce 1 Framework" target="_blank" rel="external">Part 5 Hadoop MapReduce 1 Framework</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-2-yarn/" title="Hadoop MapReduce 2 (YARN)" target="_blank" rel="external">Part 6 Hadoop MapReduce 2 (YARN)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-isnt-silver-bullet/" title="Hadoop isn’t Silver Bullet" target="_blank" rel="external">Part 7 Hadoop isn’t Silver Bullet</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/hadoop/">Hadoop</a>
    </span>
    

    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/12/05/hadoop-mapreduce-overview/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/12/05/hadoop-hdfs-high-availability/"><span>Hadoop HDFS High Availability(HA)</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/12/05/hadoop-hdfs-high-availability/" rel="bookmark">
        <time class="entry-date published" datetime="2013-12-05T06:54:59.000Z">
          2013-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>Reliability, Scalability and Availability are the most important three features for a distributed file system. In HDFS, persistent metadata, using the Secondary NameNode to create checkpoint against data loss, using block replication across the cluster against DataNode failure, all of these brings HDFS high reliability. And the master slave architecture wins HDFS great scalability. [more…]<br>However, HDFS has always had a well-known Single Point of Failure (SPOF) which impacts HDFS’s availability. HDFS fits well for ETL or batch-processing workflows, but in the past few years HDFS begin to be used for real time job, such as HBase. To recover a single NameNode, an administrator starts a new primary NameNode with FsImage and replays its EditLog, waits for Blockreport from DataNodes to leave safe mode. On large clusters with many files and blocks, it will take 30 minutes or more time to recovery. Long time recovery will impact the productivity of internal users and perhaps results in downtime visible to external users.<br>For these reasons, Hadoop community began a new feature for HDFS called High Availability Name Node (HA Name Node) in 2011. The HA makes use of an active and a standby NameNode. When the active NameNode fails, the hot standby NameNode will take over serving the role of an active NameNode without a significant interruption. </p>
<h3 id="HA-Architecture"><a href="#HA-Architecture" class="headerlink" title="HA Architecture"></a>HA Architecture</h3><p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd5.1.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd5.1.png" alt="hd5.1">Figure1 HDFS High Availability Architecture</a><br>As shown in Figure 1, HA architecture has several changes</p>
<ul>
<li>The NameNodes must use highly available shared storage to share EditLog, such as Network File System (NFS), or BookKeeper. The active NameNode will write its EditLog on the Shared dir, and the Standby NameNode polls the shared log frequently and then applies to its in-memory so as to has the most complete and up-to-date file system state in memory.</li>
<li>DataNodes must send Blockreports with block locations to both active and standy NameNodes. Because the block mappings are stored in a NameNode’s memory and not on a disk to increase data access performance.</li>
<li>Clients must be configured to handle NameNode failover, using a mechanism that is transparent to users.<br>The HA guarantees if the active NameNode fails, the standby one will take over quickly in tens of seconds, since it has the latest state available in memory: the latest EditLog entries and an up-to-date block mapping.</li>
</ul>
<h3 id="Failover"><a href="#Failover" class="headerlink" title="Failover"></a>Failover</h3><p>The transition from the active NameNode to the standby NameNode is controlled by the failover controller. Each NameNode runs a failover controller to monitor its namenode failure, which is a heartbeating mechanism. Failover is triggered when a NameNode fails.  </p>
<p>After NameNode failover, the Client must be informed which is active NameNode now. Client Failover is handled transparently by the client library. The HDFS client supports the configuration for multiple network addresses, one for each NameNode. The NameNode is identified by a single logical URI which is mapped the two network addresses of the HA Name Nodes via client-side configuration. The client will retry the two addresses until the active NameNode is found. </p>
<h3 id="Fencing"><a href="#Fencing" class="headerlink" title="Fencing"></a>Fencing</h3><p>After Failover, HDFS makes use of the fencing technique to make sure that the previous died active NameNode is prevented from doing any damage and causing corruption. These mechanisms includes killing the NameNode’s process, revoking its access to the shared storage directory and disabling its network port via a remote management command. If these techniques fail, HDFS will use STONITH, that is “shoot the other node in the head”, which uses a specialized power distribution unit to forcibly power down the host machine. </p>
<p>Resources:<br><a href="http://cyanny/myblog/2013/12/05/hadoop-overview/" title="Hadoop Overview" target="_blank" rel="external">Part 0 Hadoop Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-review/" title="Hadoop HDFS Review" target="_blank" rel="external">Part 1 Hadoop HDFS Review</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-federation/" title="Hadoop HDFS Federation" target="_blank" rel="external">Part 2 Hadoop HDFS Federation</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-high-availability/" title="Hadoop HDFS High Availability(HA)" target="_blank" rel="external">Part 3 Hadoop HDFS High Availability(HA)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-overview/" title="Hadoop MapReduce Overview" target="_blank" rel="external">Part 4 Hadoop MapReduce Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-1-framework/" title="Hadoop MapReduce 1 Framework" target="_blank" rel="external">Part 5 Hadoop MapReduce 1 Framework</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-2-yarn/" title="Hadoop MapReduce 2 (YARN)" target="_blank" rel="external">Part 6 Hadoop MapReduce 2 (YARN)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-isnt-silver-bullet/" title="Hadoop isn’t Silver Bullet" target="_blank" rel="external">Part 7 Hadoop isn’t Silver Bullet</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/hadoop/">Hadoop</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/learning/">Learning</a><a href="/tags/hadoop/">Hadoop</a><a href="/tags/research/">Research</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/12/05/hadoop-hdfs-high-availability/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/12/05/hadoop-hdfs-federation/"><span>Hadoop HDFS Federation </span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/12/05/hadoop-hdfs-federation/" rel="bookmark">
        <time class="entry-date published" datetime="2013-12-05T06:48:10.000Z">
          2013-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>In traditional HDFS architecture, there is only one NameNode in a cluster, which maintains all of the namespace and block map. Regarding that Hadoop cluster is becoming larger and larger one enterprise platform and every file and block information is in NameNode RAM, when there are more than 4000 nodes with many files, the NameNode memory will reach its limit and it becomes the limiting factor for cluster scaling. In Hadoop 2.x release series, Hadoop introduces HDFS Federation, which allows a cluster to scale by adding NameNodes, each of which manages a portion of the filesystem namespace.[more…]<br><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd4.1.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd4.1.png" alt="hd4.1">Figure1 HDFS Federation</a><br>As shown in Figure1, there are many federated NameNodes which manages its own namespace. The NameNodes are independent and don’t require coordination with each other. The DataNodes are used as common storage for blocks. Each DataNode registers with all the NameNodes in the cluster and send periodic heartbeats and block report and handles commands from the NameNodes.<br>Each NameNode is responsible for two tasks: Namespace management and Block Management. For the two tasks, mange NameNode manages its own Namespace Volume, which consists of two parts:</p>
<ul>
<li>Namespace: the metadata for each file and block</li>
<li>Block Pool: it is a set of blocks that belong to a single namespace. The Block Pool is in charge of block management task, including processing block reports and maintaining location of blocks.<br>Block pool storage is not partitioned , so DataNodes register with each NameNode in the cluster and store blocks from multiple block pools. The NameNode namespace must to generate block ID for new blocks.<br>A NameSpace Volume is a self-contained uinit . Each NameNode has no need to contact other NameNode and it’s failure will not influence other NameNode.<br>To access a federated HDFS, clients use client-side mount tables to map file paths to NameNodes. A new identifier ClusterID is added to all the nodes in the cluser. Federated NameNodes is configured by ViewFileSystem and the viewfs://URIs.<br>The HDFS Federation brings several benefits:</li>
</ul>
<ul>
<li>NameSpace Scalability: It will support large clusters with many files, just add more NameNode to scale namespace.</li>
<li>Performance: Break the limitation of single node, more NameNodes means more read/write operations and the throughput is improved.</li>
<li>Isolation: A single NameNode has no isolation in multi user environment. While multiple NameNodes can provide isolated NameSpace for both production and experiment application. </li>
</ul>
<p>Resources:<br><a href="http://cyanny/myblog/2013/12/05/hadoop-overview/" title="Hadoop Overview" target="_blank" rel="external">Part 0 Hadoop Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-review/" title="Hadoop HDFS Review" target="_blank" rel="external">Part 1 Hadoop HDFS Review</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-federation/" title="Hadoop HDFS Federation" target="_blank" rel="external">Part 2 Hadoop HDFS Federation</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-high-availability/" title="Hadoop HDFS High Availability(HA)" target="_blank" rel="external">Part 3 Hadoop HDFS High Availability(HA)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-overview/" title="Hadoop MapReduce Overview" target="_blank" rel="external">Part 4 Hadoop MapReduce Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-1-framework/" title="Hadoop MapReduce 1 Framework" target="_blank" rel="external">Part 5 Hadoop MapReduce 1 Framework</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-2-yarn/" title="Hadoop MapReduce 2 (YARN)" target="_blank" rel="external">Part 6 Hadoop MapReduce 2 (YARN)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-isnt-silver-bullet/" title="Hadoop isn’t Silver Bullet" target="_blank" rel="external">Part 7 Hadoop isn’t Silver Bullet</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/hadoop/">Hadoop</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/learning/">Learning</a><a href="/tags/hadoop/">Hadoop</a><a href="/tags/research/">Research</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/12/05/hadoop-hdfs-federation/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/12/05/hadoop-hdfs-review/"><span>Hadoop HDFS Review</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/12/05/hadoop-hdfs-review/" rel="bookmark">
        <time class="entry-date published" datetime="2013-12-05T04:00:32.000Z">
          2013-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="HDFS-Basic-Concepts"><a href="#HDFS-Basic-Concepts" class="headerlink" title="HDFS Basic Concepts"></a>HDFS Basic Concepts</h3><p>Hadoop Distributed File System, know as HDFS, is a distributed file system designed to store large data sets and streaming data sets on commodity hardware with high scalability, reliability and availability. </p>
<p>HDFS is written in Java based on the Google File System (GFS). HDFS has many advantages compared with other distributed file systems:</p>
<p><strong>1. Highly fault-tolerant</strong></p>
<p>Fault-tolerant is the core architecture for HDFS. Since HDFS can run on low-cost and unreliable hardware, the hardware has a non-trivial probability of failures. HDFS is designed to carry on working without a noticeable interruption to the user in the face of such failure. HDFS provides redundant storage for massive amounts of data and Heartbeat for failure detection.<br>When one node fails, the master will detect it and re-assign the work to a different node. Restarting a node doesn’t need communicating with other data node. When failed node restart it will be added the system automatically. If a node appears to run slowly, the master can redundantly execute another instance of the same task, know as ‘speculative execution’.[more…]</p>
<p><strong>2. Streaming Data Access</strong></p>
<p>HDFS is designed with the most efficient data processing pattern: a write once, read-many times pattern. HDFS split large files into blocks, usually 64MB or 128MB. HDFS performs best with a modest number of large files. It prefers millions, rather than billions of files, and each of which is 100MB or more. No random writes to files is allowed. Also HDFS is optimized for large, steaming reads of files. No Random reads is allowed. </p>
<p>A data set is generated and copied from source and replicated spread the HDFS system. It is efficient to load data from HDFS for big data analysis.</p>
<p><strong>3. Large data sets</strong></p>
<p>Large data means files that are MB, GB or TB in size. There are Hadoop clusters today that store PB data. HDFS support high aggregate data bandwidth and scale to hundreds of nodes in a single cluster. It also supports tens of millions of files processing.</p>
<h3 id="HDFS-NameNode-and-DataNodes-Architecture"><a href="#HDFS-NameNode-and-DataNodes-Architecture" class="headerlink" title="HDFS NameNode and DataNodes Architecture"></a>HDFS NameNode and DataNodes Architecture</h3><p>HDFS has a master/slave architecture. As shown in Figure1. </p>
<p>The <strong>master node</strong> is the NameNode, which managers the file system namespace, file metadata and regulates the access interface for files by clients. A cluster has only one NameNode, which maintain the map of file metadata and  the location of blocks. </p>
<p>The <strong>slave nodes</strong> are the DataNodes. A cluster has many DataNodes, which holds the actual data blocks.</p>
<p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd3.1.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd3.1.png" alt="hd3.1">Figure1 HDFS Architecture</a></p>
<h3 id="NameNode"><a href="#NameNode" class="headerlink" title="NameNode"></a>NameNode</h3><p>NameNode maintains the namespace tree, which is logical location and the mapping of file blocks to DataNodes, which is the physical location.</p>
<p>The NameNode executes file system namespace operations like opening, closing, and renaming files and directories. It provides POSIX interface for client, so that user can access HDFS data with Unix like commands and no need to know about the function of NameNode and DataNodes. It is kind of abstraction which decrease the complexity for data access. </p>
<p>The NameNode is the pivot in a cluster. A single NameNode greatly simplifies the architecture of HDFS. NameNode holds all of its metadata in RAM for fast access. It keeps a record of change on disk for crash recovery.</p>
<p>However, once the NameNode fails, the cluster fails. The Single Point of Failure, known as SPOF is really a bottleneck for NameNode. Hadoop 2.0 introduces NameNode Federation and High Availability to solve the problem. We will discuss these in later section.</p>
<h3 id="NameNode-Data-Persistent"><a href="#NameNode-Data-Persistent" class="headerlink" title="NameNode Data Persistent"></a>NameNode Data Persistent</h3><p>In case of NameNode crash, the namespace information and metadata updates are stored persistently on the local disk in the form of two files: the namespace image called <strong>FsImage</strong> and the <strong>EditLog</strong>.</p>
<p>FsImage is an image file persistently stores the file system namespace, including the file system tree and the metadata for all the files and the directories in the tree, the mapping of blocks to files and file system properties.</p>
<p>EditLog is a transaction log to persistently record every change that occurs to file system metadata.</p>
<p>However, we have to know there is one thing that is not persistent. The block locations we can call it Blockmap, which is stored in NameNode in-memory, not persistent on the local disk. Blockmap is reconstructed from DataNodes when the system starts by the Blockreport of DataNodes.</p>
<p>When the system starts up, NameNode will load FsImage and EditLog from the local disk, applies the transactions from the EditLog to the in-memory representation of the FsImage, and flushes out the new version of FsImage on disk. Then it truncates the old EditLog since its transactions has been applied to the FsImage. This process is called a <strong>checkpoint</strong>.</p>
<h3 id="Secondary-NameNode"><a href="#Secondary-NameNode" class="headerlink" title="Secondary NameNode"></a>Secondary NameNode</h3><p>To increase the reliability and availability of the NameNode, a separate daemon known as the Secondary NameNode takes care of some <strong>housekeeping</strong> tasks for the NameNode. Be careful that the Secondary NameNode is not a backup or a hot standby NameNode.</p>
<p>The housekeeping wok is to periodically merge the namespace image FsImage with the EditLog to prevent the EditLog becoming to large. The Secondary NameNode runs on a single Node, which is a separate physical machine with as much memory and CPU requirements as the NameNode.</p>
<p>The Secondary NameNode keeps a copy of the merged namespace image in case of the NameNode fails. But the time lags will result in data loss certainly. And during the NameNode recovery, the reconstruction of the Blockmap will cost too much time. So Hadoop works out the problem with Hadoop High Availability solution.</p>
<h3 id="DataNodes"><a href="#DataNodes" class="headerlink" title="DataNodes"></a>DataNodes</h3><p>The DataNodes holds all the actual data blocks. In sum up, it has three functions: </p>
<ul>
<li>Serves read and requests from the file system clients.</li>
<li>Provides block operations, like creation, deletion and replication upon instruction from the NameNode.</li>
<li>Make data Blockreport to NameNode periodically with lists of blocks that they are storing.</li>
</ul>
<p>In enterprise Hadoop deployment, each DataNode is a java program run on a separate JVM, and one instance of DataNode on one machine. </p>
<p>In addition, NameNode is a java program run on a single machine. Written in java provides Hadoop good portability.</p>
<h3 id="The-Communication-Protocols"><a href="#The-Communication-Protocols" class="headerlink" title="The Communication Protocols"></a>The Communication Protocols</h3><p>HDFS client, NameNode and DataNodes communication protocols are TCP/IP. Client Protocol is TCP connection between a client and NameNode. The DataNode Protocol is the connection between the NameNode and the DataNodes. HDFS makes an abstraction wraps for the Client Protocol and the DataNode Protocol, which called Remote Procedure Call (RPC). NameNode never initiates any RPCs, only responds to RPC requests from clients or DataNodes.</p>
<h3 id="HDFS-Files-Organization"><a href="#HDFS-Files-Organization" class="headerlink" title="HDFS Files Organization"></a>HDFS Files Organization</h3><p>In traditional concepts, a disk has a block size, which is the minimum amount of data that it can read or write. Disk blocks are normally 512 bytes. While HDFS has the concept of block as well, which is a much larger unit – 64MB by default.</p>
<p>HDFS large files are chopped up into 64MB or 128MB blocks. This brings several benefits:</p>
<ul>
<li>It can take advantage of any of the disks in the cluster, when the file is larger than any single disk.</li>
<li>Making the unit of abstraction of a block simplifies the storage subsystem. HDFS will deal with blocks, rather than a file. Since blocks are a fixed size, it’s easy to calculate how many can be stored on a give disk and eliminate metadata concerns.</li>
<li>Normally, a map task will operate on one local block at a time. Bocks spare the complexity of dealing with files.</li>
<li>It’s easy to do data replication with blocks for providing fault tolerance and availability. Each block is replicated multiple times. Default is to replicate each block 3 times. Replicas are stored on different nodes.</li>
<li>Block data fits well for streaming data. Files are written once and read many times. Blocks minimize the cost of seeking files.</li>
</ul>
<p>Although files are split into 64MB or 128MB blocks ， if a file is smaller than this full 64MB/128MB will not be split.</p>
<h3 id="HDFS-Data-Replication"><a href="#HDFS-Data-Replication" class="headerlink" title="HDFS Data Replication"></a>HDFS Data Replication</h3><p>HDFS each data block has a replica factor, which indicates how many times it should be replicated. Normally, the replica factor is three. Each block is replicated three times and spread on three different machines across the cluster. This provides efficient MapReduce processing because of good data locality.<br><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd3.2.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd3.2.png" alt="hd3.2">Figure2 Block Replication</a><br>As shown in Figure2, the NameNode holds the metadata for each map of file and blocks, including filename, replica factor and block-id etc. Block data are spread on different DataNodes.</p>
<h3 id="Data-Replica-Placement"><a href="#Data-Replica-Placement" class="headerlink" title="Data Replica Placement"></a>Data Replica Placement</h3><p>Block replica placement is not random. Regarding of the reliability and the performance, HDFS policy is to put one replica on one node in the local rack, the second one on a node in a different remote rack and the third one on a different node in the same remote rack.<br><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd3.3.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd3.3.png" alt="hd3.3">Figure 3 HDFS Racks</a><br>As shown in Figure 3, different DataNodes on different racks, Rack 0 and Rack1. Large HDFS instance run on a cluster of machines that commonly spread across many racks. Network bandwidth for intra-racks is greater than inter-racks. So the HDFS replica policy cuts the inter-rack write traffic and improves write performance. One third of replicas are on one node, two third of replicas are on one rack, the other third are distributed across the remaining racks. This policy guarantees the reliability.</p>
<h3 id="Data-Replication-Pipeline"><a href="#Data-Replication-Pipeline" class="headerlink" title="Data Replication Pipeline"></a>Data Replication Pipeline</h3><p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd3.4.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd3.4.png" alt="hd3.4">Figure 4 Data Replication Pipeline</a><br>As shown in Figure 4, it is the data flow of writing data to HDFS. A client request to request a file does not reach the NameNode immediately. It will follow the steps:<br>Step 1, the HDFS client caches the file data into a temporary local file until the local file accumulates data worth over one HDFS block size.<br>Step 2, the client contacts the NameNode, requests add a File.<br>Step 3, the NameNode inserts the file name into the file system tree and allocates a data block for it. Then responds to the client request with the identity of the DataNodes and the destination data block.<br>Step 4, suppose the HDFS file has a replication factor of three. The client retrieves a list of DataNodes, which contains that will host a replica of that block. The clients flushes the block of data from the local temporary file to the first DataNode.<br>Step 5,.the first DataNode starts receiving the data in small portions like 4KB, writes each portion to its local repository and transfers that portion to the second DataNode. Then the second DataNode retrieves the data portion, stores it and transfers to the third DataNode. Data is pipelined from the first DataNode to the third one.<br>Step 6, when a file is closed, the remaining un-flushed data in temporary local file is transferred to the DataNode. Then the client tells the NameNode that the file is closed.<br>Step 7, the NameNode commits the file creation operation into a persistent one. Be careful if the NameNode dies before the file is closed, the file is lost.<br>So far, we can see that file caching policy improves the writing performance. HDFS is write-once-read-many-times. When a client wants to read a file: It should contacts the NameNode to retrieves the file block map, including block id, block physical location. Then it communicates directly with the DataNodes to read data. The NameNode will not be a bottleneck for data transfer.</p>
<p>Resources:<br><a href="http://cyanny/myblog/2013/12/05/hadoop-overview/" title="Hadoop Overview" target="_blank" rel="external">Part 0 Hadoop Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-review/" title="Hadoop HDFS Review" target="_blank" rel="external">Part 1 Hadoop HDFS Review</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-federation/" title="Hadoop HDFS Federation" target="_blank" rel="external">Part 2 Hadoop HDFS Federation</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-high-availability/" title="Hadoop HDFS High Availability(HA)" target="_blank" rel="external">Part 3 Hadoop HDFS High Availability(HA)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-overview/" title="Hadoop MapReduce Overview" target="_blank" rel="external">Part 4 Hadoop MapReduce Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-1-framework/" title="Hadoop MapReduce 1 Framework" target="_blank" rel="external">Part 5 Hadoop MapReduce 1 Framework</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-2-yarn/" title="Hadoop MapReduce 2 (YARN)" target="_blank" rel="external">Part 6 Hadoop MapReduce 2 (YARN)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-isnt-silver-bullet/" title="Hadoop isn’t Silver Bullet" target="_blank" rel="external">Part 7 Hadoop isn’t Silver Bullet</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/hadoop/">Hadoop</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/learning/">Learning</a><a href="/tags/hadoop/">Hadoop</a><a href="/tags/research/">Research</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/12/05/hadoop-hdfs-review/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/12/05/hadoop-overview/"><span>Hadoop Overview</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/12/05/hadoop-overview/" rel="bookmark">
        <time class="entry-date published" datetime="2013-12-05T03:36:08.000Z">
          2013-12-05
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h3 id="The-motivation-for-Hadoop"><a href="#The-motivation-for-Hadoop" class="headerlink" title="The motivation for Hadoop"></a>The motivation for Hadoop</h3><p>Apache Hadoop is an open source distributed computing framework for large-scale data sets processing. Doug Cutting, who is the creator of Apache Lucene Project, creates it. </p>
<p>The name of Hadoop is a made-up name, which is the nickname of a stuffed yellow elephant of the kid of Doug. Hadoop has its origins in Apache Nutch, an open source web search engine, and it is built based on work done by Google in early 2000s, specifically on Google papers describing the Google File System (GFS) published in 2003, and MapReduce published in 2004. </p>
<p>Hadoop moved out of Nutch to form an independent in Feb. 2006. Up to now, Hadoop has been powered by many companies, such as Yahoo who claims it has the biggest Hadoop cluster in the world with more than 42000 nodes, LinkedIn who has 4100 nodes, Facebook who has 1400 nodes, Taobao who has the biggest cluster in China with more than 2000 nodes. [more…]</p>
<h3 id="The-problems-for-traditional-big-data-processing"><a href="#The-problems-for-traditional-big-data-processing" class="headerlink" title="The problems for traditional big data processing"></a>The problems for traditional big data processing</h3><p>Why these companies adopt Hadoop? The reason is simple, that we live in a big data age. We are flooded with big data every day on the Internet. Consider that: Facebook hosts approximately 10 billion photos, taken up on PB storage. Every second on eBay, a total merchandise value of 1400 dollars is traded and 10 million new items are listed on eBay every day. Ancestry.com, the genealogy site, store around 2.5 PB of Data.</p>
<p>How to make use of these big data to make analysis? For traditional methods, use only one machine to process computation, which needs faster processor and RAM. Even though the CPU power doubles every 18 months according to Moores’s Law, it hasn’t meet the big data analysis needs. Yet distributed system evolved to allow developers to use multiple machines for a single job, like MPI, PVM and Condor. However, programing for these traditional distributed systems is complex, you have to deal with these problems:</p>
<ul>
<li>It’s difficult to deal with partial failures of the system. Developers spend more time designing for failure than they do actually working on the problem itself.</li>
<li>Finite and precious bandwidth must be available to combine data from different disks and transfer time is very slow for big data volume.</li>
<li>Data exchange requires synchronization.</li>
<li>Temporal dependencies are complicated.</li>
</ul>
<h3 id="How-can-Hadoop-save-big-data-analysis"><a href="#How-can-Hadoop-save-big-data-analysis" class="headerlink" title="How can Hadoop save big data analysis"></a>How can Hadoop save big data analysis</h3><p>What really counts is big data. Traditional distributed computing can’t handle big data in a decent way, but Hadoop can. Lets see what Hadoop brings to us: </p>
<ul>
<li>Hadoop provide partial failure support. Hadoop Distributed File System (HDFS) can store large data sets with high reliability and scalability.</li>
<li>HDFS provide great fault tolerance. Partial Failure will not result in the failure of the entire system. And HDFS provide data recoverability for partial failure.</li>
<li>Hadoop introduce MapReduce, which spares programmers from low-level details, like partial failure. The MapReduce framework will detect failed tasks and reschedule them automatically.</li>
<li>Hadoop provide data locality. The MapReduce framework tries to collocate data with the compute nodes. Data is local, and tasks are separated with no dependence on each other. So the shared-nothing and data locality architecture can save more bandwidth and solve the complicated dependence problem</li>
</ul>
<p>In summary, Hadoop is a great big data processing tool.</p>
<h3 id="Hadoop-Basic-Concepts-and-Core-Concepts"><a href="#Hadoop-Basic-Concepts-and-Core-Concepts" class="headerlink" title="Hadoop Basic Concepts and Core Concepts"></a>Hadoop Basic Concepts and Core Concepts</h3><p>The core concepts for Hadoop are to distribute the data as it is initially stored in the system. That is data locality, individual nodes can work on data local to these nodes, and no data transfer over the network is required for initial processing.<br>Here are the basic concepts for Hadoop:</p>
<ul>
<li>Applications are written in high-level code. Developers don’t worry about network programming, temporal dependencies etc.</li>
<li>Nodes talk to each other as little as possible. Developers should not write code which communicates between nodes, that is ‘Shared-Nothing’ architecture.</li>
<li>Data is spread among machines in advance. Computation happens where the data is stored, wherever possible, just as near the node as possible. Data is replicated multiple times on the system for increased availability and reliability.</li>
</ul>
<h3 id="Hadoop-High-Level-Overview"><a href="#Hadoop-High-Level-Overview" class="headerlink" title="Hadoop High-Level Overview"></a>Hadoop High-Level Overview</h3><p>Hadoop consists of two important components: HDFS and MapReduce.<br>HDFS is Hadoop Distributed File System, which is a distributed file system designed to store large data sets and streaming data sets on commodity hardware with high scalability, reliability and availability.</p>
<p>MapReduce is a distributed processing framework designed to operate on large data stored on HDFS, which provides a clean interface for developers.</p>
<p>A set of machines running HDFS and MapReduce is known as a Hadoop Cluster. An individual machine in a cluster is known as nodes. The nodes play different roles. There are two kind important nodes: Master Nodes and Slave Nodes.</p>
<p>There are 5 important daemons on these nodes. </p>
<p><a href="http://cyanny/myblog/wp-content/uploads/2013/11/hd2.1.png" target="_blank" rel="external"><img src="http://cyanny/myblog/wp-content/uploads/2013/11/hd2.1.png" alt="hd2.1">Figure1 Hadoop High-Level Architecture</a></p>
<p>As shown in Figure, Hadoop is comprised of 5 separate daemons:</p>
<ul>
<li>NameNode, which holds the metadata for HDFS.</li>
<li>Secondary NameNode, which performs housekeeping functions for NameNode, and isn’t a backup or hot standby for the NameNode.</li>
<li>DataNode, which stores actual HDFS data blocks. In Hadoop, a large file is split into 64M or 128M blocks.</li>
<li>JobTracker, which manages MapReduce jobs, distributes individual tasks to machines running.</li>
<li>TaskTracker, which initiates and monitors each individual Map and Reduce tasks.</li>
</ul>
<p>Each daemon runs on its own Java Virtual Machine (JVM), no Nodes can run 5 daemons at the same time.  </p>
<p>Master Nodes runs the NameNode, Secondary NameNode, JobTracker daemons. And only one of each of these daemons runs on the cluster.<br>Slave Nodes run the DataNode and TaskTracker daemons. A slave node will run both of these daemons. All of these Slave Nodes run in parallel, each on their own part of the overall dataset locally.</p>
<p>Just for very small clusters, the NameNode, JobTracker and the Secondary NameNode run on a single machine. However, when there are beyond 20-30 nodes. It’s better to run each of them on individual nodes. </p>
<h3 id="Hadoop-Ecosystem"><a href="#Hadoop-Ecosystem" class="headerlink" title="Hadoop Ecosystem"></a>Hadoop Ecosystem</h3><p>Hadoop has a family of related projects based on the infrastructure for distributed computing and large-scale data processing. The core projects are apache open source projects. Except for HDFS and MapReduce, some hadoop related projects are:</p>
<ul>
<li>Ambari, a Hadoop management and cluster monitoring system.</li>
<li>Avro, a serialization system for efficient, cross-language RPC and persistent data storage.</li>
<li>Pig, a data flow language and execution environment for exploring very large datasets, which runs on HDFS and MapReduce clusters.</li>
<li>HBase, provide random, realtime read/write access to BigData. The project built a column-oriented database, host very large tables —- billions of rows X millions of columns. The project is based on Google’s paper BigTable: A Distributed Storage System for Structured Data.</li>
<li>Hive, which is distributed data warehouse. Hive manages data stored in HDFS and provides a query language based on SQL, which is translated by runtime engine to MapReduce Job.</li>
<li>Zookeeper, a distributed, highly available coordination service. It provides centralized service for maintaining configuration information, naming, providing distributed synchronization, and providing group services, which make build distributed applications more efficient.</li>
<li>Oozie, a service for running and scheduling workflows of Hadoop jobs, which includes MapReduce, Pig, Hive and sqoop jobs.</li>
<li>Mahout, a scalable machine learning libraries based on Hadoop HDFS and MapReduce.</li>
</ul>
<p>Resources:<br><a href="http://cyanny/myblog/2013/12/05/hadoop-overview/" title="Hadoop Overview" target="_blank" rel="external">Part 0 Hadoop Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-review/" title="Hadoop HDFS Review" target="_blank" rel="external">Part 1 Hadoop HDFS Review</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-federation/" title="Hadoop HDFS Federation" target="_blank" rel="external">Part 2 Hadoop HDFS Federation</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-hdfs-high-availability/" title="Hadoop HDFS High Availability(HA)" target="_blank" rel="external">Part 3 Hadoop HDFS High Availability(HA)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-overview/" title="Hadoop MapReduce Overview" target="_blank" rel="external">Part 4 Hadoop MapReduce Overview</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-1-framework/" title="Hadoop MapReduce 1 Framework" target="_blank" rel="external">Part 5 Hadoop MapReduce 1 Framework</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-mapreduce-2-yarn/" title="Hadoop MapReduce 2 (YARN)" target="_blank" rel="external">Part 6 Hadoop MapReduce 2 (YARN)</a><br><a href="http://cyanny/myblog/2013/12/05/hadoop-isnt-silver-bullet/" title="Hadoop isn’t Silver Bullet" target="_blank" rel="external">Part 7 Hadoop isn’t Silver Bullet</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/hadoop/">Hadoop</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/learning/">Learning</a><a href="/tags/hadoop/">Hadoop</a><a href="/tags/research/">Research</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/12/05/hadoop-overview/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/12/02/graph-dfs-bfs/"><span>Graph DFS and BFS</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/12/02/graph-dfs-bfs/" rel="bookmark">
        <time class="entry-date published" datetime="2013-12-02T14:26:47.000Z">
          2013-12-02
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <p>图论是一个重要的部分，以前数据结构课上过，没有作为考试要求，所以很不太熟悉，尤其是没有实现。考完试，无聊中重新看了看，想起以前在eBay，某帅哥突然开玩笑说DFS和BFS嘛，当然要会呀，Cyanny你会的吧，我说忘了，其实细细想起来，还真没有写过代码。In my view，没有实现过，就等于不会，今天实现了BFS和DFS，深深赞一个算导，说得明白和透彻，现在的算法书太多，这算是一本很不错的经典，厚了点，但要是能厚着脸皮看完确实受益匪浅。</p>
<h3 id="广度优先搜索BFS"><a href="#广度优先搜索BFS" class="headerlink" title="广度优先搜索BFS"></a>广度优先搜索BFS</h3><p>其算法思想简介：<br>1. 利用队列<br>2. 每一个Vertex引入三个变量<br>color：WHITE 表示没有访问过，GREY 表示发现，BLACK 表示完成访问<br>parent: 父亲<br>d: 表示从root到该顶点的长度<br>3. 为了实现方便，我采用int来标识每一个顶点，采用邻接表来表示graph<br>深度优先搜索可以生成深度优先树，生成单源最短路径，即从root到每一个顶点的长度是最短路径。[more…]<br>BFS可以采用邻接矩阵表示，其复杂度较高为O(n^2)<br>如果采用邻接表表示，其复杂度为O(E+V),即顶点个数+边的个数<br>[java]<br>public void BFS(int root) {<br>    vertexes = new Vertex[n];<br>    // Initialize each vertex,<br>    // Each vertex has three segment: parent, d, color<br>    for (int i = 0; i &lt; n; i++) {<br>        vertexes[i] = new Vertex(i);<br>    }</p>
<pre><code>Vertex rootv = vertexes[root];
rootv.d = 0;
rootv.color = Color.GREY;
queue.add(rootv);

while (!queue.isEmpty()) {
    Vertex u = queue.remove(0);
    ArrayList&amp;lt;Integer&amp;gt; list = graph.get(u.vertex);
    for (int i = 0; i &amp;lt; list.size(); i++) {
        Vertex temp = vertexes[list.get(i)];
        // Make sure each vertex enqueue only once
        if (temp.color == Color.WHITE) {
            temp.parent = u;
            temp.d = u.d + 1;
            temp.color = Color.GREY;
            queue.add(temp);
        }                
    }
        u.color = Color.BLACK;
    res.add(u);
}
</code></pre><p>}<br>[/java]<br><a href="https://github.com/lgrcyanny/Algorithm/blob/master/src/com/algorithm/graph/GraphBFS.java" title="BFS Source" target="_blank" rel="external">BFS Source Code</a></p>
<h3 id="深度优先搜索DFS"><a href="#深度优先搜索DFS" class="headerlink" title="深度优先搜索DFS"></a>深度优先搜索DFS</h3><p>广度优先搜索DFS，基本算法思想<br>1. 采用递归，或stack来实现<br>2. 每一个Vertex引入四个变量<br>color：WHITE 表示没有访问过，GREY 表示发现，BLACK 表示完成访问<br>parent: 父亲<br>timestamp1: 表示第一次访问该顶点的时间戳<br>timestamp2:表示访问结束时的时间戳<br>3. 为了实现方便，我采用int来标识每一个顶点，采用邻接表来表示graph</p>
<p>DFS采用邻接表表示Graph来实现，复杂度O(V+E), 矩阵复杂度依然不好，为O（n^2）<br>DFS是从多个源开始，最终会生成由多个源作为root的森林，即深度优先树（深度优先森林）。<br>同时引入时间戳，是为了获得DFS的进展情况，如果不需要时间戳，只是想简单地打印每一个顶点，可以不用。</p>
<p>以下是递归的实现方法：<br>[java]<br>    public void DFS() {<br>        int i = 0;<br>        for (i = 0; i &lt; n; i++) {<br>            vertexes[i] = new Vertex(i);<br>        }<br>        for (i = 0; i &lt; n; i++) {<br>            Vertex u = vertexes[i];<br>            if (u.color == Color.WHITE) {<br>                visitDFS(u);<br>            }<br>        }<br>    }</p>
<pre><code>private void visitDFS(Vertex u) {
    res.add(u);
    u.color = Color.GREY;
    timer++;
    u.timestamp1 = timer;
    ArrayList&amp;lt;Integer&amp;gt; adjList = graph.get(u.vertex);
    for (int i = 0; i &amp;lt; adjList.size(); i++) {
        Vertex v = vertexes[adjList.get(i)];
        if (v.color == Color.WHITE) {
            v.parent = u;
            visitDFS(v);
        }
    }
    u.color = Color.BLACK;
    timer++;
    u.timestamp2 = timer;
}
</code></pre><p>[/java]</p>
<p>以下是采用栈的实现方法改写 “visitDFS”：<br>[java]<br>    /**</p>
<pre><code> * DFS with iterative method 
 * Make use of stack
 * @param u
 */
private void visitDFSIterative(Vertex u) {
    res.add(u);
    u.color = Color.GREY;
    timer++;
    u.timestamp1 = timer;
    stack.add(u);
    while(!stack.isEmpty()) {
        Vertex v = stack.remove(stack.size() - 1);
        ArrayList&amp;lt;Integer&amp;gt; adjList = graph.get(v.vertex);
        for (int i = 0; i &amp;lt; adjList.size(); i++) {
            Vertex temp = vertexes[adjList.get(i)];
            if (temp.color == Color.WHITE) {
                temp.parent = v;
                temp.color = Color.GREY;
                timer++;
                temp.timestamp1 = timer;
                res.add(temp);
                stack.add(temp);
            }
        }
        v.color = Color.BLACK;
        timer++;
        v.timestamp2 = timer;
    }
    u.color = Color.BLACK;
    timer++;
    u.timestamp2 = timer;
}
</code></pre><p>[/java]</p>
<p><a href="https://github.com/lgrcyanny/Algorithm/blob/master/src/com/algorithm/graph/GraphDFS.java" title="DFS Source" target="_blank" rel="external">DFS Source Code</a></p>
<p>最终发现，起始实现起来代码不多，重在想法。</p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/algorithm/">Algorithm</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/algorithm/">algorithm</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/12/02/graph-dfs-bfs/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/11/27/system-analysis-design-kenneth-kendall-review-part4/"><span>System Analysis and Design (Kenneth Kendall) Review Part4</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/11/27/system-analysis-design-kenneth-kendall-review-part4/" rel="bookmark">
        <time class="entry-date published" datetime="2013-11-27T09:45:25.000Z">
          2013-11-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="9-数据库设计"><a href="#9-数据库设计" class="headerlink" title="9. 数据库设计"></a>9. 数据库设计</h2><h3 id="9-1-基本概念"><a href="#9-1-基本概念" class="headerlink" title="9.1.基本概念"></a>9.1.基本概念</h3><p>1.数据库与文件系统的区别<br>传统的文件系统：是扁平文件，无结构的文件，存储简单地数据，读取速度快，存储形式单一；存在数据冗余，更新时间长，不一致性，安全性的问题，冗余会带来插入、更新、删除异常。<br>数据库系统：是堆文件，采用数据表存储，数据存放随机且没有特定的顺序，每一个表需要提供主键；数据库提供索引功能；可以通过范式来保证数据的一致性；有事务处理功能,ACID；可以避免插入、更新、和删除异常；提供安全功能。[more…]</p>
<p>2.数据库设计的目标：<br>a)能向用户提供数据<br>b)准确性，一致性，完整性<br>c)有效的存储数据以及有效的更新和检索<br>d)有目的的检索数据，获取的数据要有利于管理和决策。</p>
<p>3.有效性目标<br>a)保证数据能被各种应用程序的用户共享。<br>b)维护数据的准确性，一致性，完整性<br>c)确保当前的和未来的应用程序所需的所有数据能立即可用<br>d)允许数据库随用户需求的增加而不断演进。<br>e)允许用户建立自己的数据视图，而不用关心数据的实际存储方式。</p>
<p>4.ERD图,要会画，可以看书中的例子<br>实体：任何由某人为手机数据而选择的对象或事件叫做实体。包括：一般实体，关联实体，属性实体。<br>关系：1对1，1对多，多对多<br>属性：实体的特征<br><img src="http://i40.tinypic.com/bf2o8n.jpg" alt="" title="ERD图"></p>
<p>5.键的类型：基于模式而不基于实例<br>a)主键：唯一标识一条记录<br>b)候选键：一个或一组可当作主键使用的键<br>c)辅助键：不能唯一标识一条记录，可以唯一，也可以标识多重记录<br>d)链接键(组合键)：可以选择两个或多个数据组成一个键<br>e)外键：一个属性，它是另外一个表的键</p>
<h3 id="9-2-规范化"><a href="#9-2-规范化" class="headerlink" title="9.2.规范化"></a>9.2.规范化</h3><p>合理规范化的模型可应对需求变更，规范化数据重复降至最少.<br>1.第一范式1NF：数据原子性，每一列只有单值属性</p>
<p>2.第二范式2NF：没有部分依赖，每一个属性不能依赖主键的部分<br>如  (学号, 课程名称) → (姓名, 年龄, 成绩, 学分) ，不符合2NF<br>因为 (课程名称) –&gt; (学分)，(学号)-&gt;(姓名，年龄)，存在部分依赖<br>此时存在数据冗余，插入异常，删除异常，更新异常</p>
<p>分解为：学生：Student(学号, 姓名, 年龄)；<br>Course(课程名称, 学分)<br>SelectCourse(学号, 课程名称, 成绩)</p>
<p>3.第三范式3NF：没有传递依赖，不存在非主属性依赖于非主属性<br>例如： (学号) → (姓名, 年龄, 所在学院, 学院地点, 学院电话),符合2NF， 但不符合3NF，因为 (所在学院) -&gt; (学院地点, 学院电话)是传递依赖，分解为：<br>(学号) → (姓名, 年龄, 所在学院)<br>(所在学院) -&gt; (学院地点, 学院电话)</p>
<p>4.BCNF(Boyce-Codd Normaml Form): nothing but the key, 首先要满足3NF，在此基础上在候选键之间不能有传递依赖。<br>如：(仓库ID, 存储物品ID) →(管理员ID, 数量)<br>　　 (管理员ID, 存储物品ID) → (仓库ID, 数量)<br>(仓库ID, 存储物品ID)和(管理员ID, 存储物品ID)都是候选关键字，表中的唯一非关键字段为数量，符合3NF。但是，由于存在如下决定关系：<br>　　 (仓库ID) → (管理员ID) 　 (管理员ID) → (仓库ID)<br>候选键之间有依赖，不符合BCNF。</p>
<p>分解为：<br>(仓库ID) –&gt; (存储物品ID，数量)<br>(仓库ID) -&gt; (管理员ID)<br>BCNF分解过细，导致查询连接性能低，所以一般3NF就可以了。</p>
<p><a href="http://www.cnblogs.com/zxsoft/archive/2007/08/03/840826.html" title="数据库范式解析" target="_blank" rel="external">数据库范式详解</a></p>
<h3 id="9-3-3NF无损连接分解方法"><a href="#9-3-3NF无损连接分解方法" class="headerlink" title="9.3.3NF无损连接分解方法"></a>9.3.3NF无损连接分解方法</h3><p>分解要做到无损连接，依赖保持。<br>考虑 关系  R= {ABCDEFGHI}<br>H -&gt; GD  E-&gt;D  HD-&gt;CE  BD -&gt; A<br>1. Right reduced<br>H -&gt; G<br>H-&gt;D<br>E-&gt;D<br>HD-&gt;C<br>HD-&gt;E<br>BD-&gt;A</p>
<p>2. Left reduced<br>H-&gt;G<br>H-&gt;D<br>E-&gt;D<br>H-&gt;C<br>H-&gt;E<br>BD-&gt;A</p>
<p>3. Find minimal cover<br>尝试删除一个依赖，然后验证是否无损和依赖保持，直到不能再删除<br>可以删除H-&gt;D,就不能再删了<br>H-&gt;G<br>E-&gt;D<br>H-&gt;C<br>H-&gt;E<br>BD-&gt;A<br>Minimal cover R’={H-&gt;GCE, E-D, BD-&gt;A}</p>
<p>4. 补充没有的依赖<br>我们发现I还没有在R’中，因此，提取出R’中的键HB构造关系HB-&gt;I</p>
<p>5. 最终结果<br>R = { H-&gt;GCE, E-D, BD-&gt;A , HB-&gt;I}</p>
<h3 id="9-4-主文件-数据库关系设计指导原则"><a href="#9-4-主文件-数据库关系设计指导原则" class="headerlink" title="9.4.主文件/数据库关系设计指导原则"></a>9.4.主文件/数据库关系设计指导原则</h3><p>1. 指导原则<br>每个单独的数据实体应创建一个主数据表。<br>一个特定的数据字段只应出现在一个主文件中。<br>每个数据表支持CRUD操作</p>
<p>2. 完整性约束<br>实体完整性：主键不能有空值，唯一键可以有空值<br>引用完整性：一对多关系中，“一端”是父表，“多端”是子表，子表的外键必须在父表中有匹配记录；父表记录只在没有子表记录关联时才能删除；父表主键更新，要进行级联更新，即对应的子表外键要更新。<br>域完整性：对数据进行有效性检验，如数据必须大于0</p>
<p>3. 异常<br>数据冗余：可以通过3NF解决<br>插入异常：如果主键重复，或未知，导致插入异常，因为违反实体完整性。<br>删除异常：删除导致相关数据丢失导致<br>更新异常：更新导致不一致性。</p>
<p>4. 检索和显示数据的步骤<br>1)从数据库中选择一个关系</p>
<p>2)连接两个关系: join(inner join, outer join, left join, right join)<br>a)inner join： A join B 只有交集会出现在结果中<br>b)left (outer) join:  A 中与B没有匹配的记录会保留<br>c)right(outer) join: B中与A没有匹配的会保留<br>d)outer join, 又叫full outer join = left join 与right join的并集，所有匹配和未匹配的记录都有 </p>
<p>3)从关系中投影出列<br>4)从关系中选择所需的行<br>5)导出新的属性<br>6)行索引或排序<br>7)计算总计值和进行性能测量<br>8)显示数据</p>
<h3 id="9-5-反规范化"><a href="#9-5-反规范化" class="headerlink" title="9.5.反规范化"></a>9.5.反规范化</h3><p>1. 原因<br>规范化的方式可以减少数据冗余，但查询速度会下降，一定的冗余，可以提升查询响应速度，避免重复引用检查表。<br>2. 反规范化的6种方法<br>1)合并1：1关系<br>2)部分合并1：<em>关系，不复制外关键字而复制非key的常用的字段<br>3)在1：</em>关系中复制FK（外关键字），减少join的表数量，将另一个表的主键复制变成外键。<br>4)在<em>：</em>关系中复制属性，避免3表join<br>5)引入重复组，将多值属性写在主表里：例如user表中多个电话号码的列，常用地址和常用电话<br>6)为了避免查询和更新这两个不可调和的矛盾，可以将更新和查询放在两张表中，从工作表提取出查询表，专门用于查询。这个方法演化成了数据仓库。这个方法只适用于查询的实时性要求不高的情况</p>
<h2 id="10-设计准确的数据输入规程"><a href="#10-设计准确的数据输入规程" class="headerlink" title="10.    设计准确的数据输入规程"></a>10.    设计准确的数据输入规程</h2><p>数据输入准确性的目标：<br>•为数据创建有意义的代码<br>•设计有效的数据获取方法<br>•保证数据的完整性和有效性<br>•通过有效性检查确保数据的质量</p>
<h3 id="10-1-有效的编码"><a href="#10-1-有效的编码" class="headerlink" title="10.1 有效的编码"></a>10.1 有效的编码</h3><h4 id="10-1-1-基本概念"><a href="#10-1-1-基本概念" class="headerlink" title="10.1.1.基本概念"></a>10.1.1.基本概念</h4><p>1.优点：<br>a)提高数据处理效率<br>b)有助于数据的排序<br>c)节约内存和存储空间<br>d)提高数据输入的准确性和效率<br>e)特定类型的编码允许我们按特定的方式处理数据</p>
<p>2.目的<br>a)记录某些事物<br>b)分类信息<br>c)隐蔽信息<br>d)展示信息<br>e)请求相应地处理</p>
<p>3.编码的一般指导原则<br>a)保持代码简洁，短代码比长代码更容易输入和记忆<br>b)保持代码稳定，不应虽每次接收新数据而变化<br>c)代码要独一无二<br>d)允许排序代码<br>e)避免使人迷惑的代码<br>f)保持代码统一<br>g)允许修改代码<br>h)代码要有意义</p>
<h3 id="10-1-2-编码的类型"><a href="#10-1-2-编码的类型" class="headerlink" title="10.1.2.编码的类型"></a>10.1.2.编码的类型</h3><p>1.记录某些事物<br>a)简单地顺序码<br>•优点：减少指派重复数字的可能性；让使用者估计出订单合适收到<br>•适用于：作业按顺序处理，需要知道数据项输入系统的顺序，需要知道事件的发生顺序。<br>•缺点：容易泄露商业信息，泄露当前已经指派了多少编码</p>
<p>b)字母衍生码<br>•例如：名字的编码： 取前2个辅音字母+名字长度+一个随机数<br>•例如编码女装：考虑品牌，类别，产地，生产日期，款号，尺码，颜色，价格<br>•常用于标识一个账号，邮寄地址标签<br>•注意：避免重复，分布要均匀<br>•缺点：如果采用名字的前三个辅音字母，当辅音字母少于3个，就会生成“RXX”这样的类型； 如果一些数据发生变化，如名字或地址变化，就会改变字母衍生码，而改变文件中的主键</p>
<p>2.分类信息<br>a)分类码<br>•目的：将一组具有特殊信息的数据从其他数据中区分出来，可以由单个字母或数字组成。是描述人物、位置、事物或事件的一种简写形式<br>•例如：计算所得税，分类有支付利息，医药费，税，捐款，应付款，生活用品支出，给每一个分类指派一个字母；<br>•使用单个字母标识分类可能会存在扩展瓶颈，可使用两个以上的字母，如计算机中的快捷键。</p>
<p>b)块顺序码<br>•是顺序码的扩展，对数据分类，对每一个分类分配一个编码范围，在该类别的项目按顺序编码<br>•例如浏览器分配100~999， 数据库 200~299<br>•优点：根据普通的特征对数据分类，还能简单地为下一个需要标识的项目（在同一块）指派一个可用的数字代码</p>
<p>3.隐藏信息<br>密码，隐藏信息，如医药处方，凯撒密码对称加密，Hash密码单向加密</p>
<p>4.展示信息：为用户展示信息，使数据输入更有意义<br>a)有效数字集编码<br>•例如衣服采用有效数字集描述产品信息，“414-219-19-12:表示浅褐色冬季外套，款式219，尺码12”<br>•优点：让员工方便的定位产品类别；查询效率高；有助于销售</p>
<p>b)助记码<br>•帮助记忆，结合字母和符号，醒目而又清晰的编码产品，例如国家简称<br>c)Unicode：显示我们不能输入和看到的字符， 国际标准组织ISO定义Unicode字符集，包括所有标准语言字符，还有65535个空位</p>
<p>5.请求相应的处理<br>a)功能码：用简短的数字或字母来标识一个计算机对数据执行的功能，通常采用顺序码或助记码的形式<br>优点：执行功能只需输入功能码，提高输入效率</p>
<h3 id="10-2-快速而高效的数据获取"><a href="#10-2-快速而高效的数据获取" class="headerlink" title="10.2.快速而高效的数据获取"></a>10.2.快速而高效的数据获取</h3><p>1.决定要获取什么样的数据<br>如果输入无用，输出也会无用<br>输入的数据分类：随每个事务而改变的数据；能简明的将正在处理的项目与所有其他项目区分出来的数据</p>
<p>2.让计算机完成数据处理：处理重复的任务，如记录事务时间，根据输入计算新值，随时保存和检索数据</p>
<p>3.减少瓶颈和减少额外输入步骤：步骤越少，引入错误的机会就越少</p>
<p>4.选择有效的数据输入方法<br>a)键盘<br>b)扫描仪<br>c)视频，音频<br>d)磁性墨水<br>e)标记识别表单：如答题纸，但缺点是用户可能会一时大意填图出错<br>f)条形码：准确度高<br>g)RFID：射频识别技术</p>
<div style="color: #EF4808"><br>两个好用的Chrome插件，小伙伴们看完复习资料支持一下吧：<br><a href="https://chrome.google.com/webstore/detail/剪影截图/gkloklemhahnoipikedmafefilidffko" title="剪影截图" target="_blank" rel="external">剪影截图：好用的网页截图，一键人人分享工具，快捷键ctrl+shift+z, 双击确定!</a><br><a href="https://chrome.google.com/webstore/detail/tss下载助手/odhkpoplnhfnhhhkgphckabboemiifle" title="TSS下载助手" target="_blank" rel="external">TSS下载助手：让你方便一键批量下载</a><br></div>

<p>资源：<br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part1/" title="System Analysis and Design (Kenneth Kendall) Review Part1" target="_blank" rel="external">系统分析与设计part1</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part2/" title="System Analysis and Design (Kenneth Kendall) Review Part2" target="_blank" rel="external">系统分析与设计part2</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part3/" title="System Analysis and Design (Kenneth Kendall) Review Part3" target="_blank" rel="external">系统分析与设计part3</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part4/" title="System Analysis and Design (Kenneth Kendall) Review Part4" target="_blank" rel="external">系统分析与设计part4</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/system-analysis-and-design/">System Analysis and Design</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/learning/">Learning</a><a href="/tags/design/">Design</a><a href="/tags/systemanalysis/">SystemAnalysis</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/11/27/system-analysis-design-kenneth-kendall-review-part4/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>



  <article>

  
    
    <h3 class="article-title"><a href="/2013/11/27/system-analysis-design-kenneth-kendall-review-part3/"><span>System Analysis and Design (Kenneth Kendall) Review Part3</span></a></h3>
    
  

  <div class="article-top-meta">
    <span class="posted-on">
      <a href="/2013/11/27/system-analysis-design-kenneth-kendall-review-part3/" rel="bookmark">
        <time class="entry-date published" datetime="2013-11-27T09:20:43.000Z">
          2013-11-27
        </time>
      </a>
    </span>
  </div>


  

  <div class="article-content">
    <div class="entry">
      
        <h2 id="6-设计有效的输出"><a href="#6-设计有效的输出" class="headerlink" title="6. 设计有效的输出"></a>6. 设计有效的输出</h2><h3 id="6-1-输出设计目标"><a href="#6-1-输出设计目标" class="headerlink" title="6.1.输出设计目标"></a>6.1.输出设计目标</h3><p>1.设计满足特定用途或组织目标的输出<br>输出要面向用户，考虑用户的年龄、收入和文化层次。</p>
<p>2.制作对用户有意义的输出<br>设计要满足特定用户的需求，决定什么是内容，什么是途径。<br>考虑输出的时间和地点 [more…]</p>
<p>3.交付合适数量的输出<br>决定要给用户多少信息，根据对用户的调查来决定，根据对象的重要性，数量和个数来决定<br>如：搜索后的结果</p>
<p>4.合理分配输出，确保重要信息是必不可少的<br>如商店的门户网站，分类信息要展示<br>对必不可少的信息进行版本化，如计算器的科学性和普通型</p>
<p>5.按时提供输出<br>In-Time 按时，及时的展现，考虑输出的时效性<br>如每年南大的主页在高考时很重要<br>如滴滴打车，采用语音输出</p>
<p>6.选择最有效的输出方式：报表，屏幕输出，音频或视频输出。</p>
<h3 id="6-2-选择输出技术时需要考虑"><a href="#6-2-选择输出技术时需要考虑" class="headerlink" title="6.2.选择输出技术时需要考虑"></a>6.2.选择输出技术时需要考虑</h3><p>1)谁将使用，看到输出。<br>2)多少人需要输出<br>3)哪里需要输出，如配送部门和后勤部门<br>4)输出的目的<br>5)输出的速度是多少<br>6)访问输出的频率如何<br>7)输出将必须存储多长时间<br>8)产生、存储和分发输出必须遵循的特殊规则是什么<br>9)维护和供应的最初与后续的成本是什么<br>10)输出技术的环境需求是什么：易接近性、噪声吸收、温度控制、设备空间、电缆架设以及WiFi发射机的接近程度。 例如：打印输出噪声很大。</p>
<h3 id="6-3-常见的输出技术"><a href="#6-3-常见的输出技术" class="headerlink" title="6.3.常见的输出技术"></a>6.3.常见的输出技术</h3><p><img src="http://i44.tinypic.com/2q9cthc.jpg" alt=""><br>补充如下：<br>1. 打印机输出：如报表行程单、化验单、信用卡账单、财务单，具有持久性，需要考虑浪费纸张的成本，噪声，采用合适的表格形式<br>2. 视频输出：<br>补充静态的打印输出。<br>远程协作，将那些不能经常见面的人联系在一起<br>教学，帮助，培训视频<br>记录当前事件，方便以后的输出<br>保存一个重要情节，收藏，存档</p>
<p>3. 动画输出：增强web站点的演示效果；比抽象的图像带来更好地决策支持。<br>4.电子邮件输出：可以用于私密信息。<br>5. 输出技术两种分类：<br>推技术：向用户推送信息，如推送流量统计，可以采用短信或电子邮件的方式。<br>拉技术：用户主动发起请求数据，如web上点击链接</p>
<h3 id="6-4-避免输出的偏差"><a href="#6-4-避免输出的偏差" class="headerlink" title="6.4.避免输出的偏差"></a>6.4.避免输出的偏差</h3><p>1.偏差的来源<br>a)信息排序的方式<br>b)可接受的边界值引入的偏差<br>c)使用图形引入的偏差</p>
<p>2.如何避免偏差<br>a)明确偏差来源<br>b)在测试Web文档的外观过程中，设计交互式输出，让各种用户参与测试，并使用各种不同的系统配置测试输出。<br>c)让用户参与输出设计，使它们认识到输出信息中可能存在的偏差<br>d)创建灵活的输出，使得用户能修改边界值和范围。<br>e)训练用户依靠多种输出对系统输出执行“逼真测试”</p>
<h3 id="6-5-印制报表的设计原则"><a href="#6-5-印制报表的设计原则" class="headerlink" title="6.5.印制报表的设计原则"></a>6.5.印制报表的设计原则</h3><p>1.确定报表设计约定<br>设计表单时要遵循的约定包括：每个位置上出现的数据类型，表单大小，以及表明连续表上数据延续部分的方式。<br>2.纸张质量、类型和大小<br>3.功能、风格和美观程度<br>4.报表的功能属性：标题、页码、准备日期、列标题、相关数据项的集合、控制分割行的使用</p>
<h3 id="6-6-设计屏幕输出"><a href="#6-6-设计屏幕输出" class="headerlink" title="6.6.设计屏幕输出"></a>6.6.设计屏幕输出</h3><p>1.原则<br>a)保持屏幕简单<br>b)保持屏幕显示的一致性<br>c)方便用户在屏幕间移动<br>d)创建吸引人的屏幕</p>
<p>2.在屏幕输出时使用图形要考虑<br>a)图形的用途<br>b)需要显示什么样的数据<br>c)读者对象<br>d)不同图形输出对读者的影响</p>
<p>3.选择仪表盘输出时考虑：<br>a)确保数据有上下文<br>b)显示合理的汇总的精度<br>c)选择合适的工作指标进行显示<br>d)公正地表现数据<br>e)选择正确的图表样式进行显示<br>f)使用精心设计的显示媒体：大小、图片、颜色、标签<br>g)限制项目类型的多样性<br>h)突出显示重要数据<br>i)将数据按有意义的小组进行编排<br>j)保持屏幕简洁<br>k)使整个仪表板保持在一个单独的屏幕上</p>
<p>4.Wedget和Gadeget输出<br>a)窗口小部件，可以个性化桌面<br>b)证券报价机、天气预报、RSS反馈可以采用widget<br>c)但widget会分散用户对系统支持的任务的注意力。</p>
<h2 id="7-设计有效的输入"><a href="#7-设计有效的输入" class="headerlink" title="7.设计有效的输入"></a>7.设计有效的输入</h2><h3 id="7-1-对输入的质量要求"><a href="#7-1-对输入的质量要求" class="headerlink" title="7.1.对输入的质量要求"></a>7.1.对输入的质量要求</h3><p>1.输入的质量<br>1)有效性：输入表单、输入屏幕和Web上的输入窗体在信息系统中服务于具体的目的。<br>2)准确性：所作出的设计能保证用户准确输入数据。<br>3)易用性：表单和屏幕简单易懂<br>4)一致性：所有输入窗体，在不同的程序中按类似的方式组织数据。<br>5)简单性：设计简洁，让用户集中注意力输入数据。<br>6)有吸引力：精心设计表单，让用户喜欢</p>
<p>2.输入还需要保证<br>完整性<br>输入顺序要合理：从主体到客体，重要到次要<br>如简历：先基本信息，再个人获奖，个人工作经历</p>
<h3 id="7-2-良好的表单设计-纸质表单"><a href="#7-2-良好的表单设计-纸质表单" class="headerlink" title="7.2.良好的表单设计(纸质表单)"></a>7.2.良好的表单设计(纸质表单)</h3><p>1.设计原则<br>a)使表单容易填写<br>b)满足用户的需求<br>c)保证输入的完整性，准确性<br>d)有吸引力</p>
<p>2.使表单容易填写<br>a)表单流：从左到右，从上到下<br>b)表单的7个部分<br>i.标题<br>ii.标识和访问控制<br>iii.用法说明<br>iv.主体<br>v.签名和确认<br>vi.总结<br>vii.评论</p>
<p>c)加标题：行标题，行下标题，加框标题，垂直选择标记，水平选择标记。<br>标题要有相关注释。<br>标题风格保持一致。</p>
<p>3.满足用户的需求<br>创建表单目的：记录、处理、保存和获取商业所需信息。</p>
<p>4.确保完整性和输入的准确性<br>这样可以让与收集数据相关的错误率大幅度降低。</p>
<p>5.表单设计要有吸引力<br>按预期顺序组织信息：姓名、街道地址、城市、州(省)、邮政编码<br>吸引力来自于正确的表单布局和流向。<br>字体样式和线条粗细也是有用的设计元素。</p>
<p>6.表单设计软件：如scansoft</p>
<p>7.业务表单控制：<br>a)确保表单的输入是为了达到特定的需求，并且该需求是组织功能不可分割的。<br>b)避免重复信息，避免使用重复表单。<br>c)设计高效的表单。<br>d)以尽可能低的成本制作表单</p>
<h3 id="7-3-良好的Web屏幕和Web窗体设计"><a href="#7-3-良好的Web屏幕和Web窗体设计" class="headerlink" title="7.3 良好的Web屏幕和Web窗体设计"></a>7.3 良好的Web屏幕和Web窗体设计</h3><h4 id="7-3-1-屏幕设计原则"><a href="#7-3-1-屏幕设计原则" class="headerlink" title="7.3.1.屏幕设计原则"></a>7.3.1.屏幕设计原则</h4><p>1.电子、web表单与静态表单的区别：<br>有光标，指示当前的数据输入位置<br>可以在上下文加入相关帮助</p>
<p>2.设计原则<br>a)保持简洁<br>b)一致性<br>c)易于用户在屏幕间移动<br>d)创建有吸引力和满意的屏幕</p>
<p>3.保持屏幕的简洁<br>屏幕输出的三个部分：<br>•标题：文件名称、下拉菜单和执行某些任务的图标<br>•主体：输入数据，从左到右，从上到下<br>•评论和用法说明<br>另一种保持简洁的方法是：使用上下文相关帮助和其他弹出窗口，利用超链接</p>
<p>4.保持屏幕一致性：<br>a)与相关的纸质表单保持一致性<br>b)每次访问新屏幕时信息出现在同一个区域<br>c)逻辑上不可分割的信息始终组织在一起</p>
<p>5.易于用户在屏幕间移动<br>a)易于用户从在不用web页之间移动<br>b)“三次单击”规则：用户应能在三次单击鼠标或按键之内，转到他们所需的屏幕。<br>c)使用向下箭头滚动屏幕<br>d)上下文相关的弹出窗口<br>e)屏幕对话</p>
<p>6.设计有吸引力的屏幕<br>a)足够的留白，让用户集中注意力到数据上<br>b)使用逻辑流计划屏幕信息，按用户处理问题的方式组织屏幕信息，让他们容易找到所需信息<br>c)将信息划分为3个部分，参见简洁性，划分遵循一致性原则<br>d)采用粗细不同的线条划分不同的类目<br>e)反转影像，闪烁光标，但要慎用。<br>f)使用不同的字体</p>
<p>7.屏幕设计中使用图标<br>a)每个应用程序使用的图标控制在20个之内<br>b)相关图标要一起出现，保持连续性和易懂性<br>c)图标含义越丰富，越有用。</p>
<h4 id="7-3-2-GUI元素的设计"><a href="#7-3-2-GUI元素的设计" class="headerlink" title="7.3.2.GUI元素的设计"></a>7.3.2.GUI元素的设计</h4><p>1.文本框：大小要能容纳所有的字符。要有标题。<br>2.复选框：标签放在复选框的右边；如果超过10个，要将他们组成一个组，并框起来。<br>3.单选按钮：选项文本放在右边；如果选项按钮超过6个，考虑下拉菜单。<br>4.下拉菜单和列表框<br>5.滑动块按钮和旋转按钮<br>6.图像映射<br>7.文本区<br>8.消息框<br>9.命令按钮</p>
<p>10.表单控件和数值：GUI界面包括的每个控件必须有某种方法来存储与控件相关的数据。 Web页面上，可以采用名称和值对来实现。 每个Web表单控件获取数值的方法是不同的。<br>11.隐藏字段：表单中，对用户不可见，但需发送到服务器的数值<br>12.事件响应图：当GUI交互很复杂时，可以采用事件响应图列出各种可能发生的事件，概要的建立商业事件和响应的模型。<br>13.动态web网页：根据用户操作改变网页内容，基于JavaScript，可以用来显示临时的信息。但对需要加密，提供安全保护的数据，不要采用动态web的形式。而缺点是用户禁用JavaScript后，网页不可用。<br>14.Ajax，异步更新，web运行更快，更流畅。缺点是JavaScript必须启用，安全性问题。</p>
<p>15.选项卡控件对话框设计原则：<br>a)为每个独特的特性创建一个分离的选项卡<br>b)将最常用的选项卡放在前面，并首先显示<br>c)可以考虑在设计的选项卡控件对话框中包含三个基本按钮：OK，Cancel，Help</p>
<p>16.Web中使用色彩<br>a)色彩搭配要协调：对比前景和背景，突出表单上重要字段，显示错误。</p>
<p>b)容易辨认的搭配：前景明亮，背景用不太明亮的。<br>i.黑底文字在黄色背景上<br>ii.绿色文字在白色背景上<br>iii.蓝色文字在白色背景上<br>iv.白色的文字在蓝色的背景上<br>v.黄色的文字在黑色的背景上</p>
<p>c)色彩不宜超过4种，对于有经验的用户，不要超过7种。</p>
<h3 id="7-4-内联网和互联网页设计"><a href="#7-4-内联网和互联网页设计" class="headerlink" title="7.4.内联网和互联网页设计"></a>7.4.内联网和互联网页设计</h3><p>指导原则<br>1)提供清楚的用法说明<br>2)演示窗体的逻辑填写顺序，特别是因为用户滚动而看不到的部分<br>3)为特殊功能增加窗体的吸引力，使用各种文本框，按钮，下拉菜单、复选框和单选按钮<br>4)如果我们不能确定用户响应某个问题时将在字段中输入多少个字符，或者不能确定用户使用什么语言、结构或窗体输入数据，提供一个可滚动的文本框<br>5)为每个Web输入窗体准备两个基本按钮：Submit 和 Clear Form<br>6)如果窗体很长，且用户进行滚动之外别无它法，那么最好将窗体分成几个简单地窗体，放在不同的网页上<br>7)创建一个错误反馈屏幕<br>对于电子商务应用程序还需要达到目标：阐明有关信任、隐私和退货方面公司的任务和价值；建立高效的事务处理过程；建立良好的客户关系。</p>
<h2 id="8-HCI人机交互"><a href="#8-HCI人机交互" class="headerlink" title="8. HCI人机交互"></a>8. HCI人机交互</h2><h3 id="8-1-基本概念"><a href="#8-1-基本概念" class="headerlink" title="8.1.基本概念"></a>8.1.基本概念</h3><p>1.HCI是指确保系统的功能和可用性，提供有效的用户交互与支持，以及增强用户快乐体验。总体目标是实现组织和个人用户的效率和有效性。<br>2.主要策略：不断引出用户对原型设计（屏幕、表单、界面等）的使用经验反馈，根据修改建议提炼设计，然后再让用户试用，直到用户满意，最后由分析员固定下来。面谈就是一种获得HCI反馈的重要方式。<br>3.技术接受模型：感知有用性和感知易用性<br>4.可用性：包括产品使用的有效性、效率和在特定环境下使用的满意度、用户界面交互，开发产品的过程，组织应用以用户为中心的设计的能力<br>5.HCI设计中考虑用户的身体因素：视觉，听觉，触觉，考虑人的缺陷、残障和意图。</p>
<p>6.良好的HCI进行系统设计的指导原则<br>1)界面与任务相匹配<br>2)提高界面效率<br>3)提供适当的反馈<br>4)生成有用的查询<br>5)提高工作者的效率</p>
<p>7.评价UI的原则<br>1)较短的学习时间<br>2)用户不用多加考虑或者不用查阅手册和帮助菜单，就可以输入指令<br>3)界面应该与实际功能“无缝”连接，确保出出错概率小<br>4)用户和系统出错后恢复时间尽可能短<br>5)偶尔使用的用户重新学习系统时要尽可能快<br>6)界面提供信息准确，界面友好</p>
<h3 id="8-2-对话设计的指导原则"><a href="#8-2-对话设计的指导原则" class="headerlink" title="8.2.对话设计的指导原则"></a>8.2.对话设计的指导原则</h3><p>1.交流要让用户和计算机都能理解，意义明确</p>
<p>2.最小化用户的行为，减少不必要的操作，可以采用以下方式：<br>1)输入时用代码代替词组<br>2)只输入系统中没有存储的数据<br>3)提供缺省信息<br>4)提供help信息，不要让用户乱操作<br>5)提供符合常规的快捷键</p>
<p>3.操作的规范化和一致性<br>1)界面的标题、日期、时间、操作提示和反馈信息固定在相同位置<br>2)使用相同的键位或者菜单退出程序<br>3)采用一致的方法取消事务<br>4)用标准化的方法获得帮助，如F1<br>5)屏幕采用标准化的色彩<br>6)GUI中使用标准化的图标<br>7)网站中术语要一致<br>8)提供一致的方法实现对话导航<br>9)文字大小、颜色和对齐方式保持一致</p>
<h3 id="8-3-用户界面类型"><a href="#8-3-用户界面类型" class="headerlink" title="8.3.用户界面类型"></a>8.3.用户界面类型</h3><p>1.自然语言界面：实现复杂，如ask.com自然语言查询，对资源有特殊要求<br>2.问答式界面，对话框，适用于不熟悉特定应用或不了解某个主体的用户</p>
<p>3.菜单：<br>优点：分类显示，不杂乱；减少界面无关信息；嵌套菜单可以提高用户的操作速度。<br>指导原则：<br>•层次和分类要清晰，不能混淆，<br>•主菜总是单停留在导航栏<br>•子菜单的层数不要超过3层<br>•下拉菜单按功能特征分区或者分组<br>•元素不要太拥挤，不重复，不遗漏，先主后次。<br>•选中主菜单的词后，弹出下拉菜单。<br>•不可用的选项灰色表示</p>
<p>4.Form表单<br>用于输入和输出<br>•原则：<br>屏幕窗体要说明应该输入什么信息，以及在哪里输出。<br>在空白字段中输入数据时，输入内容应该反白或闪烁显示。<br>为简化窗体数据的输入，可预先给出默认值。<br>•优点：打印出的表单内容是极好的文档<br>•缺点：让有经验的用户厌烦，总希望找到一种更有效的数据输入方法。</p>
<p>5.命令行:专业、学习难</p>
<p>6.对话框<br>采用标准的操作，保证一致性，交流要有意义，提供最少的操作交互和行为。</p>
<p>7.其他类型的用户界面<br>指示笔、触摸屏、语音识别与合成、触摸屏<br>语音交互的优点：让用户能腾出手来完成其他事项的同时，如驾驶，可以极大的提高数据输入速度。为有视觉或行为障碍的用户提供方便。</p>
<h3 id="8-4-为用户提供反馈"><a href="#8-4-为用户提供反馈" class="headerlink" title="8.4.为用户提供反馈"></a>8.4.为用户提供反馈</h3><p>1.反馈类型<br>a)确认接受了输入数据<br>b)确认输入格式正确</p>
<p>c)提示输入格式不正确<br>反馈可以是新的界面、消息框、音频反馈<br>反馈要保证效率和准确性</p>
<p>d)解释系统运行中的延迟<br>e)确认请求完成<br>f)提示用户请求无法完成<br>g)为用户提供更详细的反馈</p>
<p>2.在系统设计中包含反馈<br>a)提供各种帮助选项，F1，<br>b)下拉菜单帮助<br>c)鼠标悬停的提示文本<br>d)帮助向导<br>e)帮助热线</p>
<h3 id="8-5-电子商务网站的设计原则"><a href="#8-5-电子商务网站的设计原则" class="headerlink" title="8.5.电子商务网站的设计原则"></a>8.5.电子商务网站的设计原则</h3><p>1.在网站上采用各种方法从客户处获得反馈<br>在用户启动电子邮件程序的同时，自动把公司的邮件地址放在“收件人”处<br>添加反馈按钮，点击后打开信息模板</p>
<p>2.采用4种方法提供一次点击的导航，以确保用户容易地在网站中导航，并易于返回原来的网页。<br>1)建立卷滚菜单<br>2)在主页上按分层关系建立网站链接集，显示关键主题框架。<br>3)把网站地图放在主页上，并突出到该地图的链接，提高导航效率。<br>4)在网站内每一个页面上设置导航条，重复首页上的条目。</p>
<div style="color: #EF4808"><br>两个好用的Chrome插件，小伙伴们看完复习资料支持一下吧：<br><a href="https://chrome.google.com/webstore/detail/剪影截图/gkloklemhahnoipikedmafefilidffko" title="剪影截图" target="_blank" rel="external">剪影截图：好用的网页截图，一键人人分享工具，快捷键ctrl+shift+z, 双击确定!</a><br><a href="https://chrome.google.com/webstore/detail/tss下载助手/odhkpoplnhfnhhhkgphckabboemiifle" title="TSS下载助手" target="_blank" rel="external">TSS下载助手：让你方便一键批量下载</a><br></div>

<p>资源：<br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part1/" title="System Analysis and Design (Kenneth Kendall) Review Part1" target="_blank" rel="external">系统分析与设计part1</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part2/" title="System Analysis and Design (Kenneth Kendall) Review Part2" target="_blank" rel="external">系统分析与设计part2</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part3/" title="System Analysis and Design (Kenneth Kendall) Review Part3" target="_blank" rel="external">系统分析与设计part3</a><br><a href="http://cyanny/myblog/2013/11/27/system-analysis-design-kenneth-kendall-review-part4/" title="System Analysis and Design (Kenneth Kendall) Review Part4" target="_blank" rel="external">系统分析与设计part4</a></p>

      
    </div>

  </div>

  <div class="article-footer">
    <div class="article-meta pull-left">

    
      

    <span class="post-categories">
      <i class="icon-categories"></i>
        <a href="/categories/system-analysis-and-design/">System Analysis and Design</a>
    </span>
    

    
    

    <span class="post-tags">
      <i class="icon-tags"></i>
        <a href="/tags/learning/">Learning</a><a href="/tags/design/">Design</a><a href="/tags/systemanalysis/">SystemAnalysis</a>
    </span>
    

    </div>

    
    <div class="article-meta pull-right">
      <span>
        <i class="icon-comments"></i>
        <span>
          <a href="/2013/11/27/system-analysis-design-kenneth-kendall-review-part3/#comment">Comments</a>
        </span>
      </span>
    </div>
    
  </div>
</article>




<nav class="pagination">
  
  <a href="/page/3/" class="pagination-prev">Prev</a>
  
  
  <a href="/page/5/" class="pagination-next">Next</a>
  
</nav>
    </main>

    <footer class="site-footer">
  <p class="site-info">
    Copyright
    </br>
    
    &copy; 2018 Cyanny Liang
    
  </p>
</footer>
    
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
                (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-40624708-1', 'auto');
    ga('send', 'pageview');

</script>

  </div>
</div>
</body>
</html>